{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FRECKLL","text":"<p>Fast and Reduced Exoplanet Chemical Kinetics distiLLed (FRECKLL) is a chemical kinetic solver in Python that employes numerical distillation and the K-fold summation technique to solve chemical networks rapidly and accurately. The full Venot Methanol network with photochemistry can be solved to steady state in as little as 42 seconds and the reduced network in only 7 seconds!</p> <p> </p> <p>Head to the Getting Started to get started or try the Colab notebook from your web-browser!</p>"},{"location":"#references","title":"References","text":"<ul> <li>FRECKLL paper</li> <li>Methanol Network</li> <li>K-fold method</li> </ul>"},{"location":"gettingstarted/","title":"Getting Started with FRECKLL","text":"<p>The Google Colab version can be found here</p> <p>This guide is there to quickly get started on the using the <code>freckll</code> library. Here you will learn the basics:</p> <ul> <li>Loading in atmospheric data</li> <li>Loading in our network.</li> <li>Solving the atmosphere</li> <li>Plotting results</li> <li>Animating results</li> <li>Running from equilibrium</li> <li>Storing results</li> <li>Running with photochemistry.</li> </ul>"},{"location":"gettingstarted/#loading-in-atmospheric-data","title":"Loading in Atmospheric Data","text":"<p>First thing we need is profiles to solve. FRECKLL makes use of astropy to <code>units</code> to represent data. This makes the library agnostic to units. Creating a custom profile is as simple as:</p> <pre><code>from astropy import units as u\nimport numpy as np\n\ntemperature = np.linspace(2000,10000, 100) &lt;&lt; u.K\npressure = np.logspace(2,-5) &lt;&lt; u.bar\n</code></pre> <p>You can use your own methods to load in the data as long as it is in the form of a <code>Quantity</code> with correct units. FRECKLL includes some helpful methods to load in data under the <code>freckll.io.loader</code> module. For example, we will load in the TP profile using the <code>tp_profile_loader</code> function.</p> <p>Our csv file looks like this:</p> <pre><code># Pressure(mbar), Temperature (K)\n0.10002E+06    1846.3\n86374.        1841.7\n74509.        1837.4\n63753.        1836.2\n54482.        1834.9\n46559.        1833.4\n39787.        1831.9\n34001.        1830.4\n29020.        1828.9\n24720.        1828.1\n21047.        1827.5\n17919.        1826.9\n</code></pre> <ul> <li>Column 0 is Pressure in mbar</li> <li>Column 1 is temperature in K</li> </ul> <p>We can load it in using the following <code>tp_profile_loader</code> function:</p> <pre><code>from freckll.io.loader import tp_profile_loader\npressure, temperature = tp_profile_loader(\n  filename=\"tpprofile.csv\",\n  temperature_column=1, temperature_unit=u.K,\n  pressure_column=0, pressure_unit=u.mbar, comments=\"#\")\n\nprint(pressure.shape)\n</code></pre> <pre><code>(130,)\n</code></pre> <p>Additionally it would be nice to load in a \\(K_{zz}\\) profile as well. We can use a loader to do this as well.</p> <pre><code>from freckll.io.loader import kzz_profile_loader\n\n_pressure, kzz = kzz_profile_loader(\n    filename=\"kzz.csv\", kzz_column=1,pressure_column=0, kzz_unit=u.cm**2/u.s,\n    pressure_unit=u.mbar, comments=\"#\"\n)\nprint(kzz.shape)\n</code></pre> <pre><code>(28369,)\n</code></pre> <p>Sometimes different profiles lie on different pressure grids, in this case \\(K_{zz}\\) is in a much finer grid. We can get around this by interpolating the points to the TP profile grid. (Or vice-versa if you desire):</p> <pre><code>from freckll.utils import interpolate_pressure\n\nkzz = interpolate_pressure(\n    _pressure, kzz, pressure\n)\n</code></pre> <p>We can plot both profiles using the <code>freckll.plot</code> module.</p> <pre><code>from freckll.plot import plot_tp_and_kzz\nimport matplotlib.pyplot as plt\n\nfig,ax = plt.subplots()\n\nplot_tp_and_kzz(pressure, temperature, kzz, ax)\nplt.show()\n</code></pre> <p></p>"},{"location":"gettingstarted/#loading-in-the-network","title":"Loading in the Network","text":"<p>The next step is to load in the network. FRECKLL includes two Venot 2020 networks built in. The first is a full chemical network that includes photolysis and the second is a reduced network that does not include photolysis.</p> <p>You can also load in your own network but this will be covered in a different tutorial.</p> <p>The <code>default_network_loader</code> allows for two arguments:</p> <ul> <li><code>venot-methanol-2023-reduced</code> - This is the reduced network that does not include photolysis.</li> <li><code>venot-methanol-2023</code> - This is the full network that includes photolysis.</li> </ul> <p>We can use the loader to load in the reduced network:</p> <pre><code>from freckll.io.loader import default_network_loader\n\nnetwork = default_network_loader(\"venot-methanol-2023-reduced\")\n</code></pre> <p>We can inspect the species in the network:</p> <pre><code>network.species\n</code></pre> <pre><code>[C2H3O2 (CH3OCO),\n HO2 (OOH),\n C2H3O (CH2CHO),\n C2H3O (CH3CO),\n CNO (NCO),\n CH3O (CH3O),\n O2 (O2),\n CHO2 (CO2H),\n CHNO (HOCN),\n C2H5 (C2H5),\n CH3O (CH2OH),\n C2H6 (C2H6),\n C2H3 (C2H3),\n C2H2O (CH2CO),\n HN2 (NNH),\n CH2N (H2CN),\n CH4O (CH3OH),\n CN (CN),\n CH2 (1CH2),\n CHNO (HNCO),\n O (O3P),\n C2H4 (C2H4),\n CH2 (3CH2),\n CHO (HCO),\n C2H2 (C2H2),\n CH2O (H2CO),\n H2N (NH2),\n CO2 (CO2),\n HO (OH),\n CH3 (CH3),\n CHN (HCN),\n H3N (NH3),\n CH4 (CH4),\n N2 (N2),\n CO (CO),\n H2O (H2O),\n H (H),\n He (He),\n H2 (H2),\n H2N2 (N2H2),\n H3N2 (N2H3),\n CH2N (HCNH),\n CH2O2 (HOCHO),\n CH3O2 (HOCH2O),\n H2O (H2Oc[SpeciesState.LIQUID]),\n CH4 (CH4c[SpeciesState.LIQUID]),\n H3N (NH3c[SpeciesState.LIQUID])]\n</code></pre> <p>The <code>SpeciesFormula</code> is a class that contains a lot of information about a particular . It includes the following attributes:</p> <ul> <li><code>composition</code> - Number of atoms</li> <li><code>mass</code> - Mass of the species in amu</li> <li><code>state</code> - State of the species (gas, solid, liquid)</li> </ul> <pre><code>species = network.species[0]\nprint(f\"Species name: {species}\")\nprint(species.composition())\nprint(f\"Mass {species.mass}\")\nprint(f\"Charge {species.charge}\")\nprint(f\"State: {species.state}\")\nprint(f\"Diffusion Volume: {species.diffusion_volume}\")\n</code></pre> <pre><code>Species name: CH3OCO\nElement  Count  Relative mass  Fraction %\nC            2      24.021480     40.6840\nH            3       3.023823      5.1213\nO            2      31.998810     54.1948\nMass 59.044113\nCharge 0\nState: SpeciesState.GAS\nDiffusion Volume: 50.95\n</code></pre>"},{"location":"gettingstarted/#running-reactions","title":"Running reactions","text":"<p>We can solve for reactions given a set of conditions, we will use our tp-profile and a random mixing ratio to do this:</p> <pre><code>vmr = np.random.rand(len(network.species), len(pressure))\nvmr = vmr / np.sum(vmr, axis=0)\n\nreactions = network.compute_reactions(vmr, temperature, pressure)\nreactions\n</code></pre> <pre><code>[CH2CHO -&gt; CH3CO (1.36e+08) (['decomposition']),\n CH3CO -&gt; CH2CHO (4.84e+07) (['decomposition', 'inverted']),\n CH2CHO -&gt; H + CH2CO (2.68e+09) (['decomposition']),\n H + CH2CO -&gt; CH2CHO (1.84e-11) (['decomposition', 'inverted']),\n NNH -&gt; N2 + H (3.00e+08) (['decomposition']),\n ...]\n</code></pre> <p>Here each reaction is described by its <code>reactants</code>, <code>products</code>, <code>reaction_rate</code> and <code>dens_krate</code>. Where dens_krate is the reaction rate multiplied by the number density of the reactant species.</p> <pre><code>print(reactions[0])\nprint(\"Reaction rate:\",reactions[0].reaction_rate[:10], \"1/s\")\nprint(\"Reaction rate:\", reactions[0].dens_krate[:10], \"1/cm3/s\")\n</code></pre> <pre><code>CH2CHO -&gt; CH3CO (1.36e+08) (['decomposition'])\nReaction rate: [27647229.87948201 26777410.68236617 25985321.23606332 25767838.0996988\n 25533968.19290701 25266348.68916494 25001102.69660493 24738213.35402364\n 24477663.88574786 24339655.15159737] 1/s\nReaction rate: [3.81634324e+26 2.86330634e+26 2.73774059e+25 3.37740125e+25\n 7.01415174e+25 8.90572305e+25 1.81022065e+25 2.07255692e+25\n 5.89947951e+24 9.60588730e+25] 1/cm3/s\n</code></pre> <p>If we want to look for specific production/loss reactions for a specific species, we can add the <code>with_production_loss</code> argument.</p> <pre><code>reactions, (production, loss) = network.compute_reactions(vmr, temperature, pressure, with_production_loss=True)\n\nprint(production[\"CH4\"])\n</code></pre> <pre><code>[CH3 + H -&gt; CH4 (2.63e-13) (['k0', 'kinf', 'falloff', 'Troe', 'reaction', 'inverted']), H + CH3 -&gt; CH4 (1.38e-11) (['k0', 'kinf', 'falloff', 'Troe', 'reaction']), HOCHO + CH3 -&gt; CH4 + CO + OH (4.91e-12) (['corps', 'reaction', 'many body']), CH3 + H2 -&gt; CH4 + H (7.77e-13) (['corps', 'reaction', 'many body', 'inverted']), CH3 + CH3 -&gt; CH4 + 1CH2 (1.51e-13) (['corps', 'reaction', 'many body', 'inverted']), C2H3 + CH3 -&gt; CH4 + C2H2 (6.48e-13) (['corps', 'reaction', 'many body']), C2H4 + CH3 -&gt; CH4 + C2H3 (1.40e-14) (['corps', 'reaction', 'many body']), C2H5 + CH3 -&gt; C2H4 + CH4 (1.83e-12) (['corps', 'reaction', 'many body']), C2H6 + CH3 -&gt; C2H5 + CH4 (3.96e-12) (['corps', 'reaction', 'many body']), CH3 + OH -&gt; O3P + CH4 (4.62e-13) (['corps', 'reaction', 'many body', 'inverted']), CH3 + H2O -&gt; OH + CH4 (5.34e-14) (['corps', 'reaction', 'many body', 'inverted']), HCO + CH3 -&gt; CH4 + CO (1.99e-10) (['corps', 'reaction', 'many body']), CH3 + H2CO -&gt; HCO + CH4 (1.04e-11) (['corps', 'reaction', 'many body']), CH3 + OOH -&gt; O2 + CH4 (5.29e-13) (['corps', 'reaction', 'many body', 'inverted']), N2H2 + CH3 -&gt; NNH + CH4 (1.48e-12) (['corps', 'reaction', 'many body']), N2H3 + CH3 -&gt; N2H2 + CH4 (1.03e-12) (['corps', 'reaction', 'many body']), CH3 + NH3 -&gt; CH4 + NH2 (3.93e-14) (['corps', 'reaction', 'many body', 'inverted']), HOCN + CH3 -&gt; NCO + CH4 (2.96e-13) (['corps', 'reaction', 'many body']), H2CN + CH3 -&gt; HCN + CH4 (2.26e-12) (['corps', 'reaction', 'many body']), HCNH + CH3 -&gt; HCN + CH4 (2.29e-12) (['corps', 'reaction', 'many body']), HCN + CH3 -&gt; CN + CH4 (1.02e-13) (['corps', 'reaction', 'many body', 'inverted']), HNCO + CH3 -&gt; NCO + CH4 (1.20e-14) (['corps', 'reaction', 'many body', 'inverted']), CH3OH + CH3 -&gt; CH2OH + CH4 (5.79e-13) (['corps', 'reaction', 'many body']), CH3OH + CH3 -&gt; CH3O + CH4 (4.93e-14) (['corps', 'reaction', 'many body']), CH3O + CH3 -&gt; H2CO + CH4 (1.99e-11) (['corps', 'reaction', 'many body'])]\n</code></pre> <p>Additionally each reaction includes a <code>tag</code> that describes some thing about the reaction. For example, we can find only reactions that use the <code>Troe</code> falloff using the <code>find_tagged_reactions</code> function.</p> <pre><code>from freckll.network import find_tagged_reactions\n\nfind_tagged_reactions(reactions, [\"Troe\"])\n</code></pre> <pre><code>[C2H3 -&gt; C2H2 + H (2.44e+07) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n C2H2 + H -&gt; C2H3 (7.59e-13) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n C2H5 -&gt; C2H4 + H (5.36e+07) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n C2H4 + H -&gt; C2H5 (3.68e-12) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CO2H -&gt; CO + OH (4.34e+08) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n CO + OH -&gt; CO2H (3.81e-14) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CO2H -&gt; CO2 + H (6.56e+07) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n CO2 + H -&gt; CO2H (1.62e-15) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CH3OH -&gt; CH3 + OH (1.06e+04) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n CH3 + OH -&gt; CH3OH (4.54e-12) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CH3OH -&gt; 1CH2 + H2O (2.58e+03) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n 1CH2 + H2O -&gt; CH3OH (1.72e-12) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CH3OH -&gt; CH2OH + H (6.40e+01) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n CH2OH + H -&gt; CH3OH (6.83e-13) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CH3O -&gt; H2CO + H (7.83e+07) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n H2CO + H -&gt; CH3O (3.55e-15) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CH4 -&gt; CH3 + H (5.36e+00) (['k0', 'kinf', 'falloff', 'Troe', 'reaction']),\n CH3 + H -&gt; CH4 (2.63e-13) (['k0', 'kinf', 'falloff', 'Troe', 'reaction', 'inverted']),\n O2 + H -&gt; OOH (1.19e-14) (['k0', 'kinf', 'falloff', 'Troe', 'reaction']),\n OOH -&gt; O2 + H (1.16e+04) (['k0', 'kinf', 'falloff', 'Troe', 'reaction', 'inverted']),\n CH3 + CH3 -&gt; C2H6 (3.47e-12) (['k0', 'kinf', 'falloff', 'Troe', 'reaction']),\n C2H6 -&gt; CH3 + CH3 (1.12e+05) (['k0', 'kinf', 'falloff', 'Troe', 'reaction', 'inverted']),\n H + CH3 -&gt; CH4 (1.38e-11) (['k0', 'kinf', 'falloff', 'Troe', 'reaction']),\n CH4 -&gt; H + CH3 (2.39e+02) (['k0', 'kinf', 'falloff', 'Troe', 'reaction', 'inverted']),\n CO + CH3 -&gt; CH3CO (1.27e-15) (['k0', 'kinf', 'falloff', 'Troe', 'reaction']),\n CH3CO -&gt; CO + CH3 (1.37e+09) (['k0', 'kinf', 'falloff', 'Troe', 'reaction', 'inverted']),\n O2 + H -&gt; OOH (1.95e-13) (['k0', 'kinf', 'falloff', 'Troe', 'reaction']),\n OOH -&gt; O2 + H (1.88e+05) (['k0', 'kinf', 'falloff', 'Troe', 'reaction', 'inverted']),\n H2CO + H -&gt; CH2OH (8.17e-14) (['k0', 'kinf', 'falloff', 'Troe', 'reaction']),\n CH2OH -&gt; H2CO + H (1.96e+07) (['k0', 'kinf', 'falloff', 'Troe', 'reaction', 'inverted'])]\n</code></pre> <p>Or \"Troe\" and \"decomposition\":</p> <pre><code>find_tagged_reactions(reactions, [\"Troe\", \"decomposition\"])\n</code></pre> <pre><code>[CH2CHO -&gt; CH3CO (1.36e+08) (['decomposition']),\n CH3CO -&gt; CH2CHO (4.84e+07) (['decomposition', 'inverted']),\n CH2CHO -&gt; H + CH2CO (2.68e+09) (['decomposition']),\n H + CH2CO -&gt; CH2CHO (1.84e-11) (['decomposition', 'inverted']),\n NNH -&gt; N2 + H (3.00e+08) (['decomposition']),\n N2 + H -&gt; NNH (2.06e-16) (['decomposition', 'inverted']),\n HCNH -&gt; HCN + H (1.82e+07) (['decomposition']),\n HCN + H -&gt; HCNH (1.40e-14) (['decomposition', 'inverted']),\n H2CN -&gt; HCN + H (2.45e+05) (['decomposition']),\n ...\n C2H3 -&gt; C2H2 + H (2.44e+07) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n C2H2 + H -&gt; C2H3 (7.59e-13) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n C2H5 -&gt; C2H4 + H (5.36e+07) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n C2H4 + H -&gt; C2H5 (3.68e-12) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CO2H -&gt; CO + OH (4.34e+08) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n CO + OH -&gt; CO2H (3.81e-14) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n CO2H -&gt; CO2 + H (6.56e+07) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition']),\n CO2 + H -&gt; CO2H (1.62e-15) (['k0', 'kinf', 'falloff', 'Troe', 'decomposition', 'inverted']),\n ...]\n</code></pre> <p>For performance reactions can also be precompiled to a specific temperature/pressure profile. Compare this:</p> <pre><code>%timeit network.compute_reactions(vmr, temperature, pressure)\n</code></pre> <pre><code>18.9 ms \u00b1 415 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</code></pre> <p>With this:</p> <pre><code>network.compile_reactions(temperature, pressure)\n\n%timeit network.compute_reactions(vmr)\n</code></pre> <pre><code>8.97 ms \u00b1 238 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</code></pre> <p>A 50% decrease in runtime!</p>"},{"location":"gettingstarted/#solving-the-atmosphere","title":"Solving the atmosphere","text":"<p>We now want to solve the atmosphere. We require a solver to accomplish this. FRECKLL supports two solvers:</p> <ul> <li>VODE</li> <li>Rosenbrock</li> </ul> <p>For the purpose of this tutorial we will use the Rosenbrock solver. We can import our solver from <code>freckll.solver</code> and create a solver object. The solver object requires the following arguments:</p> <ul> <li><code>network</code> - The network object</li> <li><code>photochemistry</code> - A photochemistry object. This is not required if you are not using photochemistry. (We will cover this later).</li> </ul> <pre><code>from freckll.solver import Rosenbrock\n\nrosen = Rosenbrock(network=network)\n</code></pre> <p>Before we can solve the atmosphere we need to setup the conditions of the atmosphere. This includes the temperature, vmr, planetary parameters and so on. This can be done using the <code>set_system_parameters</code> method</p> <pre><code>rosen.set_system_parameters(\n    temperature=temperature,\n    pressure=pressure,\n    kzz=kzz,\n    planet_radius=1.37 * u.Rjup,\n    planet_mass=0.87 &lt;&lt; u.Mjup,\n)\n</code></pre> <p>The solver will automatically compile the networks for us so there is no need to <code>precompile</code> them beforehand. Finally we now solve our atmosphere. We will use a randomized initial mixing ratio.</p> <p>This should take no more than 20-30 seconds to run. The solver will return a <code>SolverResult</code> dictionary that contains the results of the simulation. This includes the following attributes:</p> <ul> <li><code>success</code> - A boolean that indicates if the simulation was successful</li> <li><code>times</code> - The time points of the simulation</li> <li><code>vmr</code> - The volume mixing ratio of the species at each time point</li> <li><code>initial_vmr</code> - The initial volume mixing ratio of the species</li> <li><code>temperature</code> - The temperature of the atmosphere</li> <li><code>pressure</code> - The pressure of the atmosphere</li> <li><code>density</code> - The density of the atmosphere</li> <li><code>kzz</code> - The eddy diffusion coefficient</li> <li><code>planet</code> - Planet parameters</li> <li><code>species</code> - The species in the network</li> </ul> <pre><code>vmr = np.random.rand(len(network.species), len(pressure))\nvmr = vmr / np.sum(vmr, axis=0, keepdims=True)\n\n\nresult = rosen.solve(\n    vmr=vmr,\n    t_span=[0, 1e16],\n    enable_diffusion=False,\n    maxiter=1000,\n)\n\nprint('Success:',result[\"success\"])\n</code></pre> <pre><code>Success: True\n</code></pre> <p>We have lots of plotting options available for us. Plotting the initial and steady state:</p> <pre><code>from freckll.plot import plot_vmr\n\nfig, ax = plt.subplots()\nplot_vmr(result[\"vmr\"][-1], result[\"pressure\"], result[\"species\"], initial_vmr=result[\"initial_vmr\"],\n         xlims=(1e-7, 1e0),\n         ax=ax)\nplt.show()\n</code></pre> <p></p> <p>The dashed lines are our initial conditions and the solid are the final solved state. We can also animate the results as well:</p> <pre><code>from IPython.display import HTML, Video\n</code></pre> <pre><code>%%capture\nfrom freckll.plot import animate_vmr\n\nfig, ax = plt.subplots()\n\nanim = animate_vmr(\n    vmrs=result[\"vmr\"],\n    times=result[\"times\"],\n    species=result[\"species\"],\n    pressure=result[\"pressure\"],\n    initial_vmr=result[\"initial_vmr\"],\n    xlims=(1e-7, 1e0),\n    blit=True, repeat=False,\n    interval=50,\n)\n\nanim.save(\"randomvmr.mp4\", fps=30, dpi=200, writer=\"ffmpeg\")\n</code></pre> <pre><code>Video(\"randomvmr.mp4\")\n</code></pre>"},{"location":"gettingstarted/#running-from-equilibrium","title":"Running from Equilibrium","text":"<p>Of course we may want to start from an atmosphere of given metallicity and molecular ratios. You can supply your own initial VMR as along as the first dimension maps to each species in <code>network.species</code>. The solver will then run from this initial VMR to the final state.</p> <p><code>FRECKLL</code> includes the equilibrium code <code>ACE</code> which is installed either from:</p> <pre><code>pip install freckll[ace]\n</code></pre> <p>or</p> <pre><code>pip install freckll[recommended]\n</code></pre> <p>or you can install it manually using:</p> <pre><code>pip install acepython\n</code></pre> <p>Under <code>freckll.ace</code> you can use <code>equil_chemistry_ace</code> and abundance ratios to solve for the equilibrium state of the atmosphere.</p> <pre><code>from freckll.ace import equil_chemistry_ace\n\nequil_vmr = equil_chemistry_ace(\n    temperature=temperature,\n    pressure=pressure,\n    composition=network.species,\n    elements=[\"H\", \"He\", \"C\", \"N\",\"O\"],\n    abundances=[12, 10.93, 8.39, 7.86, 8.73],\n\n)\n\nfig, ax = plt.subplots()\nplot_vmr(\n    equil_vmr,\n    pressure,\n    network.species,\n    ax=ax,\n)\nplt.show()\n</code></pre> <p></p> <p>Lets solve using this mixing ratio instead!</p> <pre><code>result_equil = rosen.solve(\n    vmr=equil_vmr,\n    t_span=[0, 1e16],\n    enable_diffusion=False,\n    maxiter=1000,\n)\nprint('Success:',result_equil[\"success\"])\n</code></pre> <pre><code>Success: True\n</code></pre> <p>Now lets plot the initial and final mixing ratios:</p> <pre><code>fig, ax = plt.subplots()\nplot_vmr(result_equil[\"vmr\"][-1], result_equil[\"pressure\"], result_equil[\"species\"], initial_vmr=result_equil[\"initial_vmr\"],\n         xlims=(1e-16, 1e0),\n         ax=ax)\nplt.show()\n</code></pre> <p></p> <p>Nice! Lets also animate the result!</p> <pre><code>%%capture\n\nanim_equil = animate_vmr(\n    vmrs=result_equil[\"vmr\"],\n    times=result_equil[\"times\"],\n    species=result_equil[\"species\"],\n    pressure=result_equil[\"pressure\"],\n    initial_vmr=result_equil[\"initial_vmr\"],\n    xlims=(1e-16, 1e0),\n    blit=True, repeat=False,\n    interval=50,\n)\n\nanim_equil.save(\"equil_vmr.mp4\", fps=30, dpi=200, writer=\"ffmpeg\")\n</code></pre> <pre><code>Video(\"equil_vmr.mp4\")\n</code></pre>"},{"location":"gettingstarted/#storing-and-reading-results","title":"Storing and Reading Results","text":"<p>We can store the output of a solution to HDF5 format using the <code>freckll.io.output</code> modules. We can simply takes the result from the solver and run this function:</p> <pre><code>from freckll.io.output import write_solution_h5py\n\nwrite_solution_h5py(\n    solution=result_equil,\n    filename=\"solution_equil.h5\",\n    overwrite=True,\n)\n</code></pre> <p>If we want to restore it, it is as easy as running the read function:</p> <pre><code>from freckll.io.output import read_h5py_solution\n\nsolution_h5 = read_h5py_solution(\"solution_equil.h5\")\n</code></pre> <p>And we can replot it to prove it is the same:</p> <pre><code>fig, ax = plt.subplots()\nplot_vmr(solution_h5[\"vmr\"][-1], solution_h5[\"pressure\"], solution_h5[\"species\"], initial_vmr=solution_h5[\"initial_vmr\"],\n         xlims=(1e-16, 1e0),\n         ax=ax)\nplt.show()\n</code></pre> <p></p>"},{"location":"gettingstarted/#running-with-photochemistry","title":"Running with Photochemistry","text":"<p>For the photochemistry case we will need to use the full network instead. We can load it in using the <code>default_network_loader</code> function:</p> <pre><code>full_network = default_network_loader(\"venot-methanol-2023\")\n</code></pre> <p>We will also need to load in the photochemistry and actinic flux for the star. This is easily accomplished using the loader modules. We will load the Venot 2020 photochemistry and the actinic flux for HD 209458 star</p> <pre><code>from freckll.io.loader import default_photonetwork_loader, default_stellar_spectra_loader\n\nphoto_network = default_photonetwork_loader(full_network.species)\nstellar_spectra = default_stellar_spectra_loader(\"hd209458\")\n</code></pre> <p>Lets plot the stellar flux and see what it looks like!</p> <pre><code>from freckll.plot import plot_stellar_flux\n\nfig, ax = plt.subplots()\nplot_stellar_flux(stellar_spectra.flux, stellar_spectra.wavelength, ax=ax)\nplt.show()\n</code></pre> <p></p> <p>We can now build a new solver with the photochemistry included. The photochemistry object is passed to the solver as an argument.</p> <pre><code>rosenbrock_photo = Rosenbrock(\n    network=full_network,\n    photochemistry=photo_network,\n    )\n</code></pre> <p>Now we can setup the photoparameters and the system parameters like so:</p> <pre><code>photo_network.set_spectra(stellar_spectra, distance=0.047 &lt;&lt; u.AU, albedo=0.0)\nrosenbrock_photo.set_system_parameters(\n    temperature=temperature,\n    pressure=pressure,\n    kzz=kzz,\n    planet_radius=1.37 * u.Rjup,\n    planet_mass=0.87 &lt;&lt; u.Mjup,\n)\n</code></pre> <p>Lets generate our new equilibrium state:</p> <pre><code>vmr_photo_equil = equil_chemistry_ace(\n    temperature=temperature,\n    pressure=pressure,\n    composition=full_network.species,\n    elements=[\"H\", \"He\", \"C\", \"N\",\"O\"],\n    abundances=[12, 10.93, 8.39, 7.86, 8.73],\n)\n</code></pre> <p>Now let us solve! This will take a little longer ~ 40 seconds to a minute:</p> <pre><code>result_photo_equil = rosenbrock_photo.solve(\n    vmr=vmr_photo_equil,\n    t_span=[0, 1e16],\n    enable_diffusion=False,\n    maxiter=1000,\n)\nprint('Success:',result_photo_equil[\"success\"])\n</code></pre> <pre><code>/Users/ahmed/Documents/repos/FRECKLL/.venv/lib/python3.12/site-packages/astropy/units/quantity.py:658: RuntimeWarning: overflow encountered in exp\n  result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n/Users/ahmed/Documents/repos/FRECKLL/.venv/lib/python3.12/site-packages/astropy/units/quantity.py:658: RuntimeWarning: invalid value encountered in multiply\n  result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n/Users/ahmed/Documents/repos/FRECKLL/.venv/lib/python3.12/site-packages/astropy/units/quantity.py:658: RuntimeWarning: overflow encountered in multiply\n  result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n\n\nSuccess: True\n</code></pre> <p>Lets plot the results!</p> <pre><code>fig, ax = plt.subplots()\nplot_vmr(result_photo_equil[\"vmr\"][-1], result_photo_equil[\"pressure\"], result_photo_equil[\"species\"], initial_vmr=result_photo_equil[\"initial_vmr\"],\n         xlims=(1e-16, 1e0),\n         ax=ax)\nplt.show()\n</code></pre> <p></p> <p>And lets animate it!</p> <pre><code>%%capture\n\nanim_photo_equil = animate_vmr(\n    vmrs=result_photo_equil[\"vmr\"],\n    times=result_photo_equil[\"times\"],\n    species=result_photo_equil[\"species\"],\n    pressure=result_photo_equil[\"pressure\"],\n    initial_vmr=result_photo_equil[\"initial_vmr\"],\n    xlims=(1e-16, 1e0),\n    blit=True, repeat=False,\n    interval=50,\n)\n\nanim_photo_equil.save(\"photo_equil_vmr.mp4\", fps=30, dpi=200, writer=\"ffmpeg\")\n</code></pre> <pre><code>Video(\"photo_equil_vmr.mp4\")\n</code></pre> <p>Thats all there is to it! Try it and see what you can solve!</p>"},{"location":"installation/","title":"Installation","text":"<p>FRECKLL has support for Python 3.9 and above. It is recommended to use a virtual environment to avoid package conflicts.</p>"},{"location":"installation/#pypi","title":"PyPi","text":"<p>FRECKLL can be installed using standard <code>pip</code> command:</p> <pre><code>pip install freckll[recommended]\n</code></pre> <p>which will install FRECKLL and additional optional dependancies.</p> <p>You can also be more specific and install only the required dependencies:</p> <pre><code>pip install freckll     # Minimum dependencies\npip install freckll[recommended] # ace and plot\npip install freckll[ace] # ACE chemistry\npip install freckll[plot] # Plotting\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>FRECKLL has the following strict requirements which will be automatically installed when using <code>pip</code>:</p> <ul> <li>Python&gt;=3.9</li> <li>astropy&gt;=5.3.2</li> <li>molmass&gt;=2024.10.25</li> <li>numba&gt;=0.60.0</li> <li>numpy&gt;=2.0.2</li> <li>scipy&gt;=1.13.1</li> </ul> <p>The following optional dependencies are also available:</p>"},{"location":"installation/#ace","title":"ace","text":"<p>Installs the ACE chemistry package. This is required for the using equilibrium chemistry as the initial start point.</p> <ul> <li>acepython&gt;=0.0.17</li> </ul>"},{"location":"installation/#plot","title":"plot","text":"<p>Installs the plotting dependencies for plotting the results of the simulation.</p> <ul> <li>matplotlib&gt;=3.9.4</li> </ul>"},{"location":"installation/#from-source","title":"From source","text":"<p>To install from source, clone the repository and install using <code>pip</code>:</p> <pre><code>git clone https://github.com/ahmed-f-alrefaie/freckll.git\ncd freckll\npip install .[recommended]\n</code></pre>"},{"location":"introduction/","title":"Introduction","text":"<p>FRECKLL (Full and Reduced Exoplanet Chemical Kinetics DistiLLed) is a Python Chemical Kinetic Solver for Exoplanetary atompsheres. The code attempts to solve the equation:</p> \\[ \\frac{\\partial n_i}{\\partial t} = P_i -L_i - \\frac{\\partial \\phi_i}{\\partial z} \\] <p>where \\(n_i\\), \\(P_i\\) and \\(L_i\\) are the number density, production rate and loss rate of species \\(i\\), \\(z\\) is the vertical coordinate of the atmosphere, and \\(\\phi_i\\) is the vertical flux for species \\(i\\) which has the form of a diffusion equation given below</p> \\[ \\phi_i = -n_i D_i \\left( \\frac{1}{n_i}\\frac{\\partial n_i}{\\partial z} + \\frac{1}{H_i} + \\frac{1}{T}\\frac{\\partial T}{\\partial z}\\right) - n_i K_{zz}\\left(\\frac{1}{y_i}\\frac{\\partial y_i}{\\partial z}\\right) \\] <p>Here, \\(D_i\\) is the molecular diffusion coefficient, \\(H_i\\) is the scale height and \\(y_i\\) the mixing ratio for species \\(i\\), T is the temperature (K) and \\(K_{zz}\\) is the eddy diffusion coefficient.</p>"},{"location":"introduction/#distillation","title":"Distillation","text":"<p>So what is FRECKLL doing differently? Its best to explain which an example. What is the output of this code?</p> <pre><code>sum([1e16, 1, -1e16])\n</code></pre> <p>This should be easy enough. Let see what python says:</p> <pre><code>&gt;&gt;&gt; sum([1e16, 1, -1e16])\n0.0\n</code></pre> <p>Wait a minute... this should be one. what is going on? Well this example hits the limit of floating point numbers. First <code>1e16 + 1</code> since the magnitude differece is so large, the 1 is lost. Then <code>1e16 - 1e16</code> is zero. So the result is zero. This is called catastrophic cancellation. For our case, reaction rates often have these type of magnitude differences. Not handling this properly can lead to discontinuous function which is not good for numerical solvers.</p> <p></p> <p>This is where FRECKLL comes in. It uses a K-sum, distillation method to avoid this problem:</p> <pre><code>&gt;&gt;&gt; from freckll.distill import ksum\n&gt;&gt;&gt; data = np.array([1e16, 1, -1e16])\n&gt;&gt;&gt; ksum(data)\nnp.float64(1.0)\n</code></pre> <p>Smooth Jacobians! Perfect for solving.</p> <p></p>"},{"location":"portingnetworks/","title":"Porting networks","text":""},{"location":"portingnetworks/#introduction","title":"Introduction","text":"<p>FRECKLL has been designed to be extensible and also to allow for the addition of new networks. The philosphy of the code is that the library contains all of the building blocks to solve the kinetic network and all the user must do is translate it into the form of FRECKLL.</p> <p>For example, the inbuilt <code>VenotChemicalNetwork</code> is simply a convienient wrapper of the <code>Network</code> class that parses the correct reactions into the correct FRECKLL functions and then adds them to the network.</p> <pre><code>class VenotChemicalNetwork(ChemicalNetwork):\n    \"\"\"A chemical network from Olivia Venot.\"\"\"\n\n    def __init__(self, network_path: pathlib.Path) -&gt; None:\n        \"\"\"Initialize the network.\n\n        Args:\n            network_path: The path to the network.\n\n        \"\"\"\n        from .io import infer_composition, load_composition, load_efficiencies, load_nasa_coeffs, load_reactions\n\n        network_path = pathlib.Path(network_path)\n        if not network_path.is_dir():\n            raise ValueError(f\"{network_path} is not a directory\")\n        composes_file = network_path / \"composes.dat\"\n        nasa_file = network_path / \"coeff_NASA.dat\"\n        efficiencies = network_path / \"efficacites.dat\"\n\n        if not composes_file.exists():\n            print(\"Inferring network from directory structure.\")\n            composition = infer_composition(network_path)\n        else:\n            composition = load_composition(composes_file)\n\n        efficiencies = load_efficiencies(efficiencies, composition)\n        nasa_coeffs = load_nasa_coeffs(nasa_file)\n        reactions = load_reactions(composition, network_path, efficiencies)\n\n        super().__init__(composition, nasa_coeffs, reactions)\n</code></pre> <p>The key three things a network requires are:</p> <ul> <li>The decoded species inside the network</li> <li>The thermochemical data of each species</li> <li>The reactions</li> </ul>"},{"location":"portingnetworks/#decoding-species","title":"Decoding Species","text":"<p>FRECKLL makes use of a <code>SpeciesFormula</code> class (a subclass of <code>Formula</code> from molmass) that automatically decomposes, and computes the mass and diffusion volume of the species. For example:</p> <pre><code>from freckll.species import SpeciesFormula\n\nh2o = SpeciesFormula(\"H2O\")\nprint(f\"Formula: {h2o}\")\nprint(f\"Mass: {h2o.mass} g/mol\")\nprint(f\"Mono mass: {h2o.monoisotopic_mass} g/mol\")\nprint(f\"Diffusion volume: {h2o.diffusion_volume}\")\nprint(h2o.composition_dict)\n</code></pre> <pre><code>Formula: H2O\nMass: 18.015287 g/mol\nMono mass: 18.01056468403 g/mol\nDiffusion volume: 13.1\n{'H': (2, 2.015882, 0.11189841161009535), 'O': (1, 15.999405, 0.8881015883899046)}\n</code></pre> <p>The <code>formula</code> argument can be any valid hill-notation chemical formula. For example one of the most important molecules in the universe can be written as:</p> <pre><code>from freckll.species import SpeciesFormula\nmol = SpeciesFormula(\"C8H10N4O2\")\nprint(f\"Formula: {mol}\")\nprint(f\"Mass: {mol.mass} g/mol\")\nprint(f\"Mono mass: {mol.monoisotopic_mass} g/mol\")\nprint(f\"Diffusion volume: {mol.diffusion_volume}\")\nprint(mol.composition_dict)\n</code></pre> <pre><code>Formula: C8H10N4O2\nMass: 194.19095199999998 g/mol\nMono mass: 194.08037557916 g/mol\nDiffusion volume: 180.68\n{'C': (8, 96.08592, 0.49480122019279255), 'H': (10, 10.07941, 0.05190463250831584), 'N': (4, 56.026812, 0.2885140189229826), 'O': (2, 31.99881, 0.1647801283759091)}\n</code></pre> <p>The class has some special properties. For example we can use a string version to compare.</p> <pre><code>from freckll.species import SpeciesFormula\n\nh2o = SpeciesFormula(\"H2O\")\n\nprint(h2o == \"H2O\") # True\n</code></pre> <p>For 99% of the time, the default argument is enough. However there will be cases where different isotopologues or electronic state must be represented. For example in the Venot network we have species:</p> <ul> <li>\\(O(^3P)\\)</li> <li>\\(O(^1D)\\)</li> </ul> <p>Which are presented as <code>O3P</code> and <code>O1D</code> in the network. The <code>SpeciesFormula</code> class by default may interpret this as <code>O3</code> and <code>P</code> or <code>O1</code> and <code>D</code>. For exmaple:</p> <pre><code>from freckll.species import SpeciesFormula\no3p = SpeciesFormula(\"O3P\")\n\nprint(o3p.composition_dict)\n</code></pre> <pre><code>{'O': (3, 47.998215, 0.6077879372478617), 'P': (1, 30.973761998, 0.3922120627521383)}\n</code></pre> <p>To avoid this, the user can specify the <code>true_formula</code> argument. This is a string that will be used to decode the species. For example:</p> <pre><code>from freckll.species import SpeciesFormula\no3p = SpeciesFormula(\"O3P\", true_formula=\"O\")\no1d = SpeciesFormula(\"O1D\", true_formula=\"O\")\nprint(o3p.composition_dict)\nprint (o1d.composition_dict)\n</code></pre> <pre><code>{'O': (1, 15.999405, 1.0)}\n{'O': (1, 15.999405, 1.0)}\n</code></pre>"},{"location":"portingnetworks/#recommended-pattern","title":"Recommended pattern","text":"<p>When loading in a species, we recommend the following pattern:</p> <ul> <li>A map of exceptions</li> <li>A <code>_decode_species</code> function that takes a string and returns a <code>SpeciesFormula</code> object.</li> </ul> <p>For example, with the previous example, we have this pattern:</p> <pre><code>from freckll.species import SpeciesFormula\n\n_species_exceptions = {\n    \"O3P\": SpeciesFormula(\"O3P\", true_formula=\"O\"),\n    \"O1D\": SpeciesFormula(\"O1D\", true_formula=\"O\"),\n}\n\ndef _decode_species(species: str) -&gt; SpeciesFormula:\n    \"\"\"Decode the species.\n\n    Args:\n        species: The species to decode.\n\n    Returns:\n        The decoded species.\n\n    \"\"\"\n    if species in _species_exceptions:\n        return _species_exceptions[species]\n    else:\n        return SpeciesFormula(species)\n</code></pre>"},{"location":"portingnetworks/#thermochemical-data","title":"Thermochemical data","text":"<p>FRECKLL uses the 7-coeff NASA polynomial to represent the thermochemical data of a particular species. The <code>freckll.NasaCoeff</code> class is a simple dataclass that allows you to directly assign data to the class. For example:</p> <pre><code>from freckll.nasa import NasaCoeff\n\nnasa = NasaCoeff(\n    species=SpeciesFormula(\"H2O\"),\n    x1=1000.0,\n    x2=2000.0,\n    x3=3000.0,\n    a_coeff=np.array([1,2,3,4,5,6,7])\n    b_coeff=np.array([1,2,3,4,5,6,7])\n)\n</code></pre> <p>You can then call the <code>nasa</code> object to get the thermochemical data \\(\\frac{H}{RT}\\) and \\(\\frac{S}{R}\\). For example:</p> <pre><code>temperature = np.array([1000, 2000, 3000]) * u.K\nh, s = nasa(temperature)\n</code></pre> <p>A FRECKLL <code>Network</code> requires the user to supply a list of <code>NasaCoeff</code> objects corresponding to the species in the network.</p> <pre><code>species_nasa = [\n    NasaCoeff(\n        species=SpeciesFormula(\"H2O\"),\n        x1=1000.0,\n        x2=2000.0,\n        x3=3000.0,\n        a_coeff=np.array([1,2,3,4,5,6,7])\n        b_coeff=np.array([1,2,3,4,5,6,7])\n    ),\n    NasaCoeff(\n        species=SpeciesFormula(\"CO\"),\n        x1=1000.0,\n        x2=2000.0,\n        x3=3000.0,\n        a_coeff=np.array([1,2,3,4,5,6,7])\n        b_coeff=np.array([1,2,3,4,5,6,7])\n    )\n]\n...\n</code></pre>"},{"location":"portingnetworks/#recommended-pattern_1","title":"Recommended pattern","text":"<p>When loading in NASA coefficients, we recommend the following pattern:</p> <ul> <li>Make use of the <code>decode_species</code> function to decode the species</li> </ul> <p>For example if we have nasa coeffs of this format:</p> <pre><code># My fabulous NASA coefficient format\nH2O 1000.0 2000.0 3000.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0\nCO 1000.0 2000.0 3000.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0\n...\n</code></pre> <p>We could load them in like this:</p> <pre><code>from freckll.nasa import NasaCoeff\nfrom typing import Callable\nfrom freckll.species import SpeciesFormula\n\ndef load_nasa(nasa_file: str,\n    decode_species: Callable[[str], SpeciesFormula]) -&gt; list[NasaCoeff]:\n    \"\"\"Load the NASA coefficients from a file.\n\n    Args:\n        nasa_file: The path to the NASA coefficients file.\n        decode_species: The function to decode the species.\n\n    Returns:\n        A list of NasaCoeff objects.\n\n    \"\"\"\n    with open(nasa_file, \"r\") as f:\n        lines = f.readlines()\n\n    nasa_coeffs = []\n    for line in lines:\n        if line.startswith(\"#\"):\n            continue\n        data = line.split()\n        species = decode_species(data[0])\n        x1 = float(data[1])\n        x2 = float(data[2])\n        x3 = float(data[3])\n        a_coeff = np.array([float(x) for x in data[4:11]])\n        b_coeff = np.array([float(x) for x in data[11:18]])\n        nasa_coeffs.append(NasaCoeff(species, x1, x2, x3, a_coeff, b_coeff))\n\n    return nasa_coeffs\n</code></pre>"},{"location":"portingnetworks/#reactions","title":"Reactions","text":"<p>Reactions are represented by two objects. A <code>ReactionCall</code> which executes the reaction and a <code>Reaction</code> which contains the computed reaction data. All reactions under <code>freckll.reaction</code> do not produce a result but instead return a function of the form:</p> <pre><code>def reaction(concentration) -&gt; list[Reaction]:\n    ...\n</code></pre> <p>The usage pattern is therefore:</p> <pre><code>react_func = k0kinf(&lt;argshere&gt;)\nreaction_rate = react_func(concentration)\n\nprint(reaction_rate[0])\nprint(reaction_rate[1]) # If reversible\n</code></pre> <p>This is what is actually happening when reactions are compiled. The appropriate function is created and then is reused. Every reaction has these parameters at the end:</p> <ul> <li><code>temperature</code></li> <li><code>pressure</code></li> <li><code>thermo_reactants</code></li> <li><code>thermo_products</code></li> </ul> <p>Where <code>thermo_reactants</code> and <code>thermo_products</code> are arrays of \\(H\\) and \\(S\\) for the reactants and products respectively. These are used to compute the reversible reaction rate. Using this we can determine the <code>fixed</code> parameters of the reaction, the <code>compiled</code> parameters and the <code>variable</code> parameters.</p> <p>Fixed:</p> <ul> <li>Reaction specific</li> <li>Do not change with regards to temperature, pressure or concentration</li> <li>Example: Arrhenius parameters</li> </ul> <p>Compiled:</p> <ul> <li>Reaction specific</li> <li>Change with regards to temperature, pressure or thermochemical data</li> <li>Does not change during a solve</li> <li>Example: Reversible reactions, temperature/pressure dependance.</li> </ul> <p>Variable:</p> <ul> <li>Reaction specific</li> <li>Changes every time step</li> <li>Concentration/Number density of the species</li> </ul> <p>We can use partial to create a function that stores all of the fixed parameters (such as Arrhenius parameters) and then returns a function that takes the compiled parameters (such as temperature, pressure and thermochemical data) which then returns a function that takes the variable parameters (such as concentration). For example, we could compile a reversible many-body reaction like this:</p> <pre><code>from freckll.reaction import ReactionCall\nfrom freckll.reaction import corps_reaction\nfrom functools import partial\n\nspecies = [SpeciesFormula(\"O2\"), SpeciesFormula(\"H2\"), SpeciesFormula(\"H2O2\")]\n\n# Compiling H2 + O2 &lt;=&gt; H2O2\n\ninverted = True\n\n\nk_coeffs = [\n    10.0, # A\n    3.0, # n\n    100.0, # Er\n]\n\nreactants = [\n    SpeciesFormula(\"H2\"),\n    SpeciesFormula(\"O2\"),\n]\n\nproducts = [\n    SpeciesFormula(\"H2O2\"),\n]\n\nreaction_call = ReactionCall(\n    species,  # All species in network\n    reactants,  # Reactants\n    products,  # Products\n    [\"corps\", \"reaction\", \"many body\"], # Tags to identify reaction\n    inverted, # Reaction is reversible\n    partial(react.corps_reaction, k_coeffs, inverted, reactants, products), # Our partial function\n)\n</code></pre> <p>This reaction call can be passed into a network to be used to compute reaction rates.</p>"},{"location":"portingnetworks/#available-reactions","title":"Available reactions","text":"<p>All reactions present are reversible if used with <code>invert=True</code></p> <ul> <li><code>k0kinf_reaction</code>: \\(k_0\\) and \\(k_\\infty\\) 2-body reaction.</li> <li><code>decomposition_k0kinf_reaction</code>: Decomposition reaction with \\(k_0\\) and \\(k_\\infty\\).</li> <li><code>corps_reaction</code>: Many body reaction</li> <li><code>k0_reaction</code>: 2-body reaction with \\(k_0\\).</li> <li><code>decomposition_reaction</code>: Decomposition reaction with \\(k_0\\).</li> <li><code>de_excitation_reaction</code>: De-excitation reaction with \\(k_0\\).</li> <li><code>manybody_plog_reaction</code>: Many body reaction with PLOG.</li> <li><code>decomposition_plog_reaction</code>: Decomposition reaction with PLOG.</li> </ul> <p>Additionally reactions with \\(k_0\\) and \\(k_\\infty\\) can use one of two falloff functions from <code>freckl.reactions.falloff</code>:</p> <ul> <li><code>troe_falloff_term</code>: Troe falloff term</li> <li><code>sri_falloff_term</code>: Stanford Research Institute falloff function</li> </ul>"},{"location":"portingnetworks/#recommended-pattern_2","title":"Recommended pattern","text":"<p>When loading in reactions, we recommend the following pattern:</p> <ul> <li>Using the <code>decode_species</code> function to decode the species</li> <li>A <code>map_reaction</code> that maps a reaction to the correct reaction function</li> <li>Use partial to fix the reaction parameters</li> </ul> <p>For example, if we have a reaction file of the form:</p> <pre><code># k_0 k_inf\nH20 + O2 &lt;=&gt; H2O2,  8.306E-12,  0.000E+00,  0.000E+00,  2.000E+00,  1.000E+02, 8.306E-12,  0.000E+00,  0.000E+00,  2.000E+00,  1.000E+02,\n...\n\n#Decomposition\nCO2 =&gt; CO + O2,    1.000E+13,  0.000E+00,  2.363E+04,  1.260E+00,  0.000E+00\n...\n</code></pre> <p>We could load them in like this:</p> <pre><code>from freckll.reaction import ReactionCall\nfrom freckll.reaction import k0kinf_reaction, decomposition_reaction\nfrom functools import partial\nfrom typing import Callable\nfrom freckll.species import SpeciesFormula\n\n\ndef load_reactions(\n    species: list[SpeciesFormula], # Species in whole network\n    reaction_file: str,\n    decode_species: Callable[[str], SpeciesFormula],\n) -&gt; list[ReactionCall]:\n\n    _map_reaction = {\n        \"k0 kinf\": k0kinf_reaction,\n        \"Decomposition\": decomposition_reaction,\n    }\n\n    chosen_reaction = None\n\n    reaction_calls = []\n\n    with open(reaction_file, \"r\") as f:\n        for line in f:\n            if line.startswith(\"#\"):\n                chosen_reaction = _map_reaction[line[1:].strip()]\n                continue\n            data = line.split(\",\")\n\n            invert = '&lt;=&gt;' in line\n\n            coeffs = [float(x) for x in data[1:]]\n            reactants = data[0].split(\"&lt;=&gt;\")[0].split(\"+\")\n            products = data[0].split(\"&lt;=&gt;\")[1].split(\"+\")\n\n            reactants = [decode_species(x.strip()) for x in reactants]\n            products = [decode_species(x.strip()) for x in products]\n\n            reaction_call = ReactionCall(\n                species,\n                reactants,\n                products,\n                [\"reaction\"],\n                invert,\n                partial(chosen_reaction, coeffs, invert, reactants, products),\n            )\n\n            reaction_calls.append(reaction_call)\n    return reaction_calls\n</code></pre>"},{"location":"portingnetworks/#creating-the-network","title":"Creating the network","text":"<p>Creating a network is simply putting all of these together and passing them into the <code>Network</code> class. For example:</p> <pre><code>from freckll.network import Network\n\nloaded_species = load_species(\"species.txt\", decode_species)\nloaded_nasa = load_nasa(\"nasa.txt\", decode_species)\nloaded_reactions = load_reactions(\"reactions.txt\", decode_species)\n\nnetwork = Network(\n    loaded_species,\n    loaded_nasa,\n    loaded_reactions,\n)\n</code></pre> <p>This will create a network that can be used to solve the kinetic equations. You can simply pass this into a solver</p> <pre><code>from freckll.solver import RosenbrockSolver\n\nsolver = RosenbrockSolver(network)\nsolver.solve(\n    initial_conditions,\n    t_span=[0,1e10],\n    ...\n)\n</code></pre>"},{"location":"portingnetworks/#photochemistry","title":"Photochemistry","text":"<p>Photochemistry is a bit different. Photochemistry only requires two data sources: The actinic flux and the cross sections.</p>"},{"location":"portingnetworks/#actinic-flux","title":"Actinic flux","text":"<p>This is handled by the <code>StarSpectra</code> class, it only requires three arguments. The spectral grid and the actinic flux and the reference distance.</p> <pre><code>from freckll.reactions.photo import StarSpectra\nfrom astropy import units as u\n\nss = StarSpectra(\n    spectral_grid=np.linspace(100, 2000, 1000) * u.nm,\n    actinic_flux=np.ones(1000) * u.photon / (u.cm**2 * u.s * u.nm),\n    reference_distance=1.0 * u.AU,\n)\n</code></pre> <p>The spectral grid is the wavelength grid of the actinic flux and the reference distance is the distance of the measured flux. The actinic flux must be in units that are analagous/convertable to \\(\\frac{photons}{cm^2 s nm}\\). FRECKLL will handle the conversion for you so you can use any units you like. The <code>StarSpectra</code> class will also handle the conversion of the spectral grid to the correct units.</p>"},{"location":"portingnetworks/#photomolecule","title":"PhotoMolecule","text":"<p><code>PhotoMolecule</code> is a class that represents a molecule with cross-section and quantum yields.</p> <p>[To be continued]</p>"},{"location":"cli/cli/","title":"FRECKLL Command Line Interface","text":"<p>The FRECKLL command line interface (CLI) allows you to solve for atmospheric chemistry using standard <code>yaml</code> input files.</p> <p>Example files can be found here</p>"},{"location":"cli/cli/#usage","title":"Usage","text":"<p><code>freckll</code> is a command line tool that can be run from the terminal. The basic usage is:</p> <pre><code>freckll [OPTIONS] INPUT\n</code></pre> <p>The help message can be printed using the <code>-h</code> or <code>--help</code> flag:</p> <pre><code>Usage: freckll [OPTIONS] INPUT\n\n  Run the Freckll simulation.\n\n  Args:\n  input: Path to the input file.\n  output: Path to the output file.\n  overwrite: Overwrite the output file if it exists.\n  plot: Plot the results.\n  plot_path: Path to save the plots.\n  plot_prefix: Prefix for the plot filenames.\n  animate: Animate the results.\n\nOptions:\n  -o, --output PATH   Output file to write.  [required]\n  --overwrite         Overwrite the output file if it exists.\n  --plot              Plot the results.\n  --plot-path PATH    Path to save the plots.\n  --plot-prefix TEXT  Prefix for the plot filenames.\n  --animate           Animate the results.\n  --help              Show this message and exit.\n</code></pre>"},{"location":"cli/cli/#cli-options","title":"CLI options","text":""},{"location":"cli/cli/#-o-or-output","title":"<code>-o</code> or <code>--output</code>","text":"<p>Running one of the example files can be done using the following command:</p> <pre><code>freckll -o result.hdf5 example.yaml\n</code></pre> <p>The output file will be saved as <code>result.hdf5</code> in the current directory. If the file already exists then FRECKLL will refuse to run unless the <code>--overwrite</code> flag is used.</p> <p>You can read the hdf5 file using the <code>read_h5py_solution</code> function from the <code>freckll.io.output</code> module. Here is an example of how to do this:</p> <pre><code>from freckll.io.output import read_h5py_solution\n\nsolution_h5 = read_h5py_solution(\"solution_equil.h5\")\n</code></pre>"},{"location":"cli/cli/#plotting","title":"Plotting","text":"<p>freckll can plot the results using the <code>--plot</code> flag. The plots will be saved in the current directory with the prefix <code>freckll_</code>. The plot will be saved as a png file. The <code>--plot-path</code> option can be used to specify a different directory to save the plots. The <code>--plot-prefix</code> option can be used to specify a different prefix for the plot filenames.</p> <pre><code>freckll -o result.hdf5 example.yaml --plot --plot-path ./plots --plot-prefix my_plot\n</code></pre>"},{"location":"cli/cli/#animation","title":"Animation","text":"<p>freckll can animate the results using the <code>--animate</code> flag. The animation will be saved in the current directory with the prefix <code>freckll_</code>. The animation will be saved as a mp4 file. The <code>--plot-path</code> option can be used to specify a different directory to save the plots. The <code>--plot-prefix</code> option can be used to specify a different prefix for the plot filenames.</p> <pre><code>freckll -o result.hdf5 example.yaml --animate --plot-path ./plots --plot-prefix my_plot\n</code></pre> <p>The animation will be saved as <code>my_plot_animation.mp4</code> in the <code>./plots</code> directory.</p>"},{"location":"cli/cli/#failure","title":"Failure","text":"<p>If the simulation fails (Due to solver issues, timeout, maxiter limits etc), the output file will be saved with the suffix <code>_failed.hdf5</code>. Additionally, if plots and animations are requested, they will be saved with the suffix <code>_failed.png</code> and <code>_failed.mp4</code> respectively. The output file will contain the last state of the simulation before it failed. This can be useful for debugging and understanding what went wrong.</p>"},{"location":"cli/inputfile/","title":"Yaml file format","text":"<p>FRECKLL CLI uses the YAML file format for input files. The YAML file is a human-readable data serialization format that is easy to read and write.</p> <p>For certain data types, FRECKLL yaml files can accept units in the form of strings. For example, the following are all valid:</p> <pre><code>planet_radius: 1.0 Rjup\n</code></pre> <pre><code>planet_radius: 1.0 Rearth\n</code></pre> <pre><code>planet_radius: 20000 km\n</code></pre> <p>Generally all of the astropy units are accepted. In the documentation, we will use the following format to denote units:</p> <ul> <li><code>[length]</code> for any length unit: e.g. <code>m</code>, <code>cm</code>, <code>km</code>, <code>Rjup</code>, <code>Rearth</code>, etc.</li> <li><code>[time]</code> for any time unit: e.g. <code>s</code>, <code>min</code>, <code>hr</code>, <code>day</code>, <code>yr</code>, etc.</li> <li><code>[mass]</code> for any mass unit: e.g. <code>kg</code>, <code>g</code>, <code>Mearth</code>, <code>Mjup</code>, etc.</li> <li><code>[temperature]</code> for any temperature unit: e.g. <code>K</code>, <code>C</code>, <code>F</code>, etc.</li> <li><code>[pressure]</code> for any pressure unit: e.g. <code>Pa</code>, <code>bar</code>, etc.</li> <li><code>[spectral]</code> for any spectral unit: e.g. <code>nm</code>, <code>um</code>, <code>cm-1</code>, etc.</li> <li><code>[flux]</code> for any flux unit: e.g. <code>W/m2/nm</code>, <code>erg/s/cm2/nm</code>, etc.</li> <li><code>[kinetic]</code> for any kinematic viscosity unit: e.g. <code>cm2/s</code>, <code>m2/s</code>, etc.</li> </ul> <p>Generally square units can be defined as either <code>[unit]2</code> or <code>[unit]**2</code>. For example, <code>m2</code> and <code>m**2</code> are both valid. The same applies to cube units, e.g. <code>m3</code> and <code>m**3</code>.</p>"},{"location":"cli/inputfile/#example-input-file","title":"Example input file","text":"<pre><code>planet:\n  mass: 0.714 Mjup\n  radius: 1.38 Rjup\n  distance: 0.04747 AU\n  albedo: 0.0\n\nstar:\n  incident_angle: 45 deg\n  spectrum: hd209458\n\n# Built in format\nnetwork: venot-methanol-2023-reduced\nphotochemistry: venot-methanol-2023-photo\n\nthermochemistry:\n  format: ace\n  abundances: [12.0, 10.925, 9.168, 7.86, 8.633]\n  elements: [H, He, C, N, O]\n\natmosphere:\n  tp_profile:\n    format: from-file\n    filename: tpprofile.csv\n    temperature_column: 1\n    pressure_column: 0\n    comments: \"#\"\n    temperature_unit: K\n    pressure_unit: mbar\n\n  kzz:\n    format: from-file\n    filename: kzz.csv\n    kzz_column: 1\n    pressure_column: 0\n    comments: \"#\"\n    kzz_unit: cm2/s\n    pressure_unit: mbar\n\nsolver:\n  method: rosenbrock\n  t_span: [0.0, 1e10]\n  max_iter: 100\n  nevals: 200\n  dn_crit: 1e-3\n  dndt_crit: 1e-6\n  max_solve_time: 1 hour\n  enable_diffusion: false\n  rtol: 1e-2\n  atol: 1e-25\n  maxiter: 100\n</code></pre> <p>We will go through each of the sections in the input file in detail. The input file is divided into the following sections:</p> <ul> <li><code>planet</code>: This section contains the properties of the planet, such as mass, radius, distance from the star, and albedo.</li> <li><code>star</code>: This section contains the properties of the star, such as the incident angle and spectrum.</li> <li><code>network</code>: This section contains the name of the chemical network to be used. The network can be either a built-in network or a custom network.</li> <li><code>photochemistry</code>: This section contains the name of the photochemistry network to be used. The network can be either a built-in network or a custom network.</li> <li><code>thermochemistry</code>: This section contains the thermochemistry data, such as the format of the data and the abundances of the elements.</li> <li><code>atmosphere</code>: This section contains the properties of the atmosphere, such as the temperature profile and eddy diffusion coefficient.</li> <li><code>solver</code>: This section contains the properties of the solver, such as the method to be used, the time span, and the maximum number of iterations.</li> </ul>"},{"location":"cli/inputfile/#planet","title":"Planet","text":"<p>The <code>planet</code> section contains the properties of the planet. It is a required section and must be present in the input file. The following properties are available:</p> <ul> <li><code>mass</code></li> <li>Format: <code>[mass]</code></li> <li>Required</li> <li>The mass of the planet in [mass] (e.g. <code>1 Mjup</code>, <code>2 Mearth</code>, etc.).</li> <li><code>radius</code></li> <li>Format: <code>[length]</code></li> <li>Required</li> <li>The radius of the planet in <code>[length]</code> (e.g. <code>2 Rjup</code>, <code>1 Rearth</code>, etc.).</li> <li><code>distance</code></li> <li>Format: <code>[length]</code></li> <li>Required for photochemistry. Optional otherwise.</li> <li>The distance of the planet from the star in <code>[length]</code> (e.g. <code>1 AU</code>, <code>2 km</code>, etc.).</li> <li><code>albedo</code></li> <li>Format: <code>float</code></li> <li>Optional (Used in Photochemistry)</li> <li>Determines how much flux reflects back from the BOA.</li> <li>Default is <code>0.0</code>.</li> </ul>"},{"location":"cli/inputfile/#example","title":"Example","text":"<pre><code>planet:\n  mass: 0.714 Mjup\n  radius: 1.38 Rjup\n  distance: 0.04747 AU\n  albedo: 0.0\n</code></pre>"},{"location":"cli/inputfile/#star","title":"Star","text":"<p>The <code>star</code> section contains the properties of the star. It is a required section if <code>photochemistry</code> is enabled.</p> <p>The following properties are available:</p> <ul> <li> <p><code>incident_angle</code></p> </li> <li> <p>Format: <code>[angle]</code></p> </li> <li>Optional</li> <li>The angle of the star with respect to the planet in [angle] (e.g. <code>10 deg</code>, <code>1.2 rad</code>, etc.).</li> <li> <p>Default is <code>45.0 deg</code>.</p> </li> <li> <p><code>spectrum</code></p> </li> <li>Format: <code>string</code> or <code>rescale</code> or <code>from-file</code></li> <li>Required if <code>photochemistry</code> is enabled.</li> <li>The spectrum of the star. The spectrum can be either a built-in spectrum/custom spectrum/rescale from empirical data.</li> <li>The built-in spectrum can be one of the following: <code>55cnc</code>, <code>adleo</code>, <code>gj436</code>, <code>gj3470</code>, <code>hd128167</code>, <code>hd189733</code>, <code>hd209458</code>, <code>sun</code>, <code>wasp12</code>, <code>wasp39</code>, <code>wasp43</code></li> </ul>"},{"location":"cli/inputfile/#example_1","title":"Example","text":"<pre><code>star:\n  incident_angle: 45 deg\n  spectrum: hd209458\n</code></pre>"},{"location":"cli/inputfile/#from-file-spectrum","title":"from-file spectrum","text":"<p>The <code>from-file</code> option can be used to specify a custom spectrum file. Freckll supports a CSV file format. The arguments are as follows:</p> <ul> <li><code>filename</code></li> <li>Format: <code>Path</code></li> <li>Required</li> <li>The path to the custom spectrum file. The file should be in CSV format.</li> <li><code>flux_column</code></li> <li>Format: <code>int</code></li> <li>Required</li> <li>The column number of the flux data in the CSV file. The first column is <code>0</code>.</li> <li><code>spectral_column</code></li> <li>Format: <code>int</code></li> <li>Required</li> <li>The column number of the spectral data in the CSV file. The first column is <code>0</code>.</li> <li><code>flux_unit</code></li> <li>Format: <code>string</code></li> <li>Required</li> <li>The unit of the flux data. The unit should be in the form of a string (e.g. <code>W/m2/nm</code>, <code>erg/s/cm2/nm</code>, etc.).</li> <li><code>spectral_unit</code></li> <li>Format: <code>string</code></li> <li>Required</li> <li>The unit of the spectral data. The unit should be in the form of a string (e.g. <code>nm</code>, <code>um</code>, <code>cm-1</code>, etc.).</li> <li><code>reference_distance</code></li> <li>Format: <code>[length]</code></li> <li>Required</li> <li>The reference distance for the flux data in <code>[length]</code> (e.g. <code>1 AU</code>, <code>1 km</code>, etc.).</li> <li><code>skiprows</code></li> <li>Format: <code>int</code></li> <li>Optional</li> <li>The number of rows to skip at the beginning of the file. Default is <code>0</code>.</li> <li><code>delimiter</code></li> <li>Format: <code>string</code></li> <li>Optional</li> <li>The delimiter used in the CSV file. Default is <code>None</code>.</li> <li><code>comments</code></li> <li>Format: <code>string</code></li> <li>Optional</li> <li>The character used to denote comments in the CSV file. Default is <code>None</code>.</li> </ul>"},{"location":"cli/inputfile/#example_2","title":"Example","text":"<pre><code>star:\n  incident_angle: 45 deg\n  spectrum:\n    format: from-file\n    filename: spectrum.csv\n    flux_column: 1\n    spectral_column: 0\n    flux_unit: W/m2/nm\n    spectral_unit: nm\n    reference_distance: 1 AU\n    skiprows: 0\n    delimiter: \",\"\n    comments: \"#\"\n</code></pre>"},{"location":"cli/inputfile/#rescale","title":"Rescale","text":"<p>The <code>rescale</code> option can be used to generate a custom spectrum from one of the built-in spectra. The arguments are as follows:</p> <ul> <li><code>from_star</code></li> <li>Format: <code>string</code></li> <li>Required</li> <li>The name of the built-in star spectrum to be used as a reference. The built-in spectrum can be one of the following: <code>55cnc</code>, <code>adleo</code>, <code>gj436</code>, <code>gj3470</code>, <code>hd128167</code>, <code>hd189733</code>, <code>hd209458</code>, <code>sun</code>, <code>wasp12</code>, <code>wasp39</code>, <code>wasp43</code></li> <li><code>temperature</code></li> <li>Format: <code>[temperature]</code></li> <li>Required</li> <li>The temperature of the new star in <code>[temperature]</code> (e.g. <code>6117 K</code>, <code>3000 K</code>, etc.).</li> <li><code>radius</code></li> <li>Format: <code>[length]</code></li> <li>Required</li> <li>The radius of the new star in <code>[length]</code> (e.g. <code>1.16 Rsun</code>, <code>2 Rjup</code>, etc.).</li> </ul>"},{"location":"cli/inputfile/#example_3","title":"Example","text":"<pre><code>star:\n  incident_angle: 45 deg\n  spectrum:\n    format: rescale\n    from_star: sun\n    temperature: 6117 K\n    radius: 1.16 Rsun\n</code></pre>"},{"location":"cli/inputfile/#network","title":"Network","text":"<p>The <code>network</code> section defines the chemical network of the simulation. It is a required section and must be present in the input file.</p> <p>To use the built in network only requires the name of the network. For example:</p> <pre><code>network: venot-methanol-2023-reduced\n</code></pre> <p>The available built-in networks are:</p> <ul> <li><code>venot-methanol-2023-reduced</code></li> <li>Reduced network for the Venot et al. (2020) methanol network.</li> <li><code>venot-methanol-2023</code></li> <li>Full network for the Venot et al. (2020) methanol network.</li> </ul>"},{"location":"cli/inputfile/#custom-network","title":"Custom network","text":"<p>If you want to use a custom network, you can specify the path to the network file. The arguments are as follows:</p> <ul> <li><code>format</code></li> <li>Format: <code>string</code></li> <li>Required</li> <li>The name of the chemical network to be used. Only <code>venot</code> format is supported.</li> </ul>"},{"location":"cli/inputfile/#venot-format","title":"Venot format","text":"<p>The <code>venot</code> format is a custom format used by FRECKLL. The arguments are as follows:</p> <ul> <li><code>network_path</code></li> <li>Format: <code>Path</code></li> <li>Required</li> <li>The path to the custom network file. The file should be in the <code>venot</code> format.</li> </ul>"},{"location":"cli/inputfile/#example_4","title":"Example","text":"<pre><code>network:\n  format: venot\n  network_path: path/to/network\n</code></pre>"},{"location":"cli/inputfile/#photochemistry","title":"Photochemistry","text":"<p>The <code>photochemistry</code> section contains the name of the photochemistry network to be used. When included, photochemistry will be enabled.</p> <p>Similar to the Network section, the photochemistry section can either be a built-in network or a custom network. The following built-in photochemistry networks are available:</p> <ul> <li><code>venot-methanol-2023-photo</code></li> <li>Photochemistry network for the Venot et al. (2020) methanol network.</li> </ul>"},{"location":"cli/inputfile/#example_5","title":"Example","text":"<pre><code>photochemistry: venot-methanol-2023-photo\n</code></pre>"},{"location":"cli/inputfile/#custom-photochemistry","title":"Custom photochemistry","text":"<p>If you want to use a custom photochemistry network. The arguments are as follows:</p> <ul> <li><code>format</code></li> <li>Format: <code>string</code></li> <li>Required</li> <li>The name of the photochemistry network to be used. Only <code>venot</code> format is supported.</li> </ul>"},{"location":"cli/inputfile/#venot-format_1","title":"Venot format","text":"<p>The <code>venot</code> format is a custom format used by FRECKLL. The arguments are as follows:</p> <ul> <li><code>photodissociation_file</code></li> <li>Format: <code>Path</code></li> <li>Required</li> <li>The path to the custom photodissociation file. The file should be in the <code>venot</code> format.</li> <li><code>cross_section_path</code></li> <li>Format: <code>Path</code></li> <li>Required</li> <li>The path to the cross-section folder.</li> <li>Must include both <code>se*</code> and <code>qy*</code> files.</li> </ul>"},{"location":"cli/inputfile/#example_6","title":"Example","text":"<pre><code>photochemistry:\n  format: venot\n  photodissociation_file: path/to/photodissociation\n  cross_section_path: path/to/cross_section\n</code></pre>"},{"location":"cli/inputfile/#thermochemistry","title":"Thermochemistry","text":"<p>The <code>thermochemistry</code> section contains the thermochemistry data. It is a required section and must be present in the input file.</p> <p>Currently only <code>ace</code> is supported. The arguments are as follows:</p> <ul> <li><code>format</code></li> <li>Format: <code>string</code></li> <li>Required</li> <li>The name of the thermochemistry format to be used. Only <code>ace</code> format is supported.</li> <li><code>elements</code></li> <li>Format: <code>list</code></li> <li>Required</li> <li>The elements in the thermochemistry data. The elements should be in the form of a list (e.g. <code>[H, He, C, N, O]</code>).</li> <li><code>abundances</code></li> <li>Format: <code>list</code></li> <li>Required</li> <li>The abundances of the elements in the thermochemistry data. The abundances should be in the form of a list (e.g. <code>[12.0, 10.925, 9.168, 7.86, 8.633]</code>).</li> <li>Abundances should correspond to the elements in the same order.</li> <li><code>therm_file</code></li> <li>Format: <code>Path</code></li> <li>Optional</li> <li>The path to the NASA thermochemistry file. The file should be in the <code>ace</code> format.</li> <li>If not defined then FRECKLLs built-in ACE file will be used.</li> </ul>"},{"location":"cli/inputfile/#example_7","title":"Example","text":"<pre><code>thermochemistry:\n  format: ace\n  abundances: [12.0, 10.925, 9.168, 7.86, 8.633]\n  elements: [H, He, C, N, O]\n  therm_file: path/to/NASA.therm\n</code></pre>"},{"location":"cli/inputfile/#atmosphere","title":"Atmosphere","text":"<p>The <code>atmosphere</code> section contains the properties of the atmosphere. It is a required section and must be present in the input file.</p> <p>The following properties are available:</p> <ul> <li> <p><code>tp_profile</code></p> </li> <li> <p>Defines the temperature profile of the atmosphere. The arguments are as follows:</p> </li> <li><code>format</code><ul> <li>Format: <code>string</code></li> <li>Required</li> <li>The format of the temperature profile. Only <code>from-file</code> is supported.</li> </ul> </li> <li><code>filename</code><ul> <li>Format: <code>Path</code></li> <li>Required</li> <li>The path to the temperature profile file. The file should be in CSV format.</li> </ul> </li> <li><code>temperature_column</code><ul> <li>Format: <code>int</code></li> <li>Required</li> <li>The column number of the temperature data in the CSV file. The first column is <code>0</code>.</li> </ul> </li> <li><code>pressure_column</code><ul> <li>Format: <code>int</code></li> <li>Required</li> <li>The column number of the pressure data in the CSV file. The first column is <code>0</code>.</li> </ul> </li> <li><code>comments</code><ul> <li>Format: <code>string</code></li> <li>Optional</li> <li>The character used to denote comments in the CSV file. Default is <code>#</code>.</li> </ul> </li> <li><code>temperature_unit</code><ul> <li>Format: <code>string</code></li> <li>Required</li> <li>The unit of the temperature data. The unit should be in the form of a string (e.g. <code>K</code>, <code>C</code>, <code>F</code>, etc.).</li> </ul> </li> <li><code>pressure_unit</code><ul> <li>Format: <code>string</code></li> <li>Required</li> <li>The unit of the pressure data. The unit should be in the form of a string (e.g. <code>Pa</code>, <code>bar</code>, etc.).</li> </ul> </li> <li><code>skiprows</code><ul> <li>Format: <code>int</code></li> <li>Optional</li> <li>The number of rows to skip at the beginning of the file. Default is <code>0</code>.</li> </ul> </li> <li><code>delimiter</code><ul> <li>Format: <code>string</code></li> <li>Optional</li> <li>The delimiter used in the CSV file. Default is <code>None</code>.</li> </ul> </li> <li> <p><code>start</code></p> <ul> <li>Format: <code>top</code> or <code>bottom</code></li> <li>Optional</li> <li>Whether the profile starts from the top or bottom of the atmosphere. Default is <code>bottom</code>.</li> </ul> </li> <li> <p><code>kzz</code></p> </li> <li>Defines the eddy diffusion coefficient profile of the atmosphere. The arguments are as follows:</li> <li><code>format</code><ul> <li>Format: <code>string</code></li> <li>Required</li> <li>The format of the eddy diffusion coefficient profile. Only <code>from-file</code> is supported.</li> </ul> </li> <li><code>filename</code><ul> <li>Format: <code>Path</code></li> <li>Required</li> <li>The path to the eddy diffusion coefficient profile file. The file should be in CSV format.</li> </ul> </li> <li><code>kzz_column</code><ul> <li>Format: <code>int</code></li> <li>Required</li> <li>The column number of the eddy diffusion coefficient data in the CSV file. The first column is <code>0</code>.</li> </ul> </li> <li><code>pressure_column</code><ul> <li>Format: <code>int</code></li> <li>Required</li> <li>The column number of the pressure data in the CSV file. The first column is <code>0</code>.</li> </ul> </li> <li><code>comments</code><ul> <li>Format: <code>string</code></li> <li>Optional</li> <li>The character used to denote comments in the CSV file. Default is <code>#</code>.</li> </ul> </li> <li><code>kzz_unit</code><ul> <li>Format: <code>string</code></li> <li>Required</li> <li>The unit of the eddy diffusion coefficient data. The unit should be in the form of a string (e.g. <code>cm2/s</code>, <code>m2/s</code>, etc.).</li> </ul> </li> <li><code>pressure_unit</code><ul> <li>Format: <code>string</code></li> <li>Required</li> <li>The unit of the pressure data. The unit should be in the form of a string (e.g. <code>Pa</code>, <code>bar</code>, etc.).</li> </ul> </li> <li><code>skiprows</code><ul> <li>Format: <code>int</code></li> <li>Optional</li> <li>The number of rows to skip at the beginning of the file. Default is <code>0</code>.</li> </ul> </li> <li><code>delimiter</code><ul> <li>Format: <code>string</code></li> <li>Optional</li> <li>The delimiter used in the CSV file. Default is <code>None</code>.</li> </ul> </li> <li><code>start</code><ul> <li>Format: <code>top</code> or <code>bottom</code></li> <li>Optional</li> <li>Whether the profile starts from the top or bottom of the atmosphere. Default is <code>bottom</code>.</li> </ul> </li> <li><code>interpolate_kzz</code></li> <li>Format: <code>bool</code></li> <li>Optional</li> <li>Whether to interpolate the eddy diffusion coefficient profile. Default is <code>True</code>.</li> </ul> <p>For <code>kzz</code> it is also possible to use a constant value. e.g</p> <pre><code>atmosphere:\n  tp_profile: ...\n\n  kzz: 1e10 cm2/s\n</code></pre>"},{"location":"cli/inputfile/#example_8","title":"Example","text":"<pre><code>atmosphere:\n  tp_profile:\n    format: from-file\n    filename: tpprofile.csv\n    temperature_column: 1\n    pressure_column: 0\n    comments: \"#\"\n    temperature_unit: K\n    pressure_unit: Pa\n\n  kzz:\n    format: from-file\n    filename: kzz.csv\n    kzz_column: 1\n    pressure_column: 0\n    comments: \"#\"\n    kzz_unit: m2/s\n    pressure_unit: bar\n\ninterpolate_kzz: true\n</code></pre>"},{"location":"cli/inputfile/#solver","title":"Solver","text":"<p>The <code>solver</code> section contains the properties of the solver. It is a required section and must be present in the input file. Only two solvers are currently available: <code>rosenbrock</code> and <code>vode</code>.</p> <p>All solvers have these properties:</p> <pre><code>          vmr: FreckllArray,\n          t_span: tuple[float, float],\n          enable_diffusion: bool = False,\n          atol: float = 1e-25,\n          rtol: float = 1e-2,\n          df_criteria: float = 1e-3,\n          dfdt_criteria: float = 1e-8,\n</code></pre> <ul> <li> <p><code>method</code></p> </li> <li> <p>Format: <code>string</code></p> </li> <li>Required</li> <li> <p>The method to be used. Only <code>rosenbrock</code> and <code>vode</code> are supported.</p> </li> <li> <p><code>t_span</code></p> </li> <li>Format: <code>list[float,float]</code></li> <li>Required</li> <li>The start and end time of the simulation</li> <li>The time span should be in the form of a list (e.g. <code>[0.0, 1e10]</code>).</li> <li><code>enable_diffusion</code></li> <li>Format: <code>bool</code></li> <li>Optional</li> <li>Whether to enable molecular diffusion. Default is <code>False</code>.</li> <li><code>atol</code></li> <li>Format: <code>float</code></li> <li>Optional</li> <li>The absolute tolerance of the solver. Default is <code>1e-25</code>.</li> <li><code>rtol</code></li> <li>Format: <code>float</code></li> <li>Optional</li> <li>The relative tolerance of the solver. Default is <code>1e-3</code>.</li> <li><code>df_criteria</code></li> <li>Format: <code>float</code></li> <li>Optional</li> <li>The criteria for convergence of the solver.</li> <li>Defined as \\(|y_{i} - y_{i-1}| &lt; \\Delta f\\).</li> <li>Default is <code>1e-3</code>.</li> <li><code>dfdt_criteria</code></li> <li>Format: <code>float</code></li> <li>Optional</li> <li>The criteria for convergence of the solver.</li> <li>Defined as \\(\\frac{|y_{i} - y_{i-1}|}{t_i - t_{i-1}} &lt; \\frac{\\Delta f}{\\Delta t}\\).</li> <li>Default is <code>1e-8</code>.</li> </ul>"},{"location":"cli/inputfile/#rosenbrock","title":"Rosenbrock","text":"<p>The <code>rosenbrock</code> solver has the following additional properties:</p> <ul> <li><code>maxiter</code></li> <li>Format: <code>int</code></li> <li>Optional</li> <li>The maximum number of iterations for the solver. Default is <code>100</code>.</li> <li><code>nevals</code></li> <li>Format: <code>int</code></li> <li>Optional</li> <li>The number of evaluations to store in the solution.</li> <li>These are evenly spaced in \\(\\log_{10}(t)\\).</li> <li>The results are interpolated to these points.</li> <li>Default is <code>200</code>.</li> <li> <p><code>timestep_reject_factor</code></p> </li> <li> <p>Format: <code>float</code></p> </li> <li>Optional</li> <li>The factor by which to reduce the timestep if the solver fails a step.</li> <li> <p>Default is <code>0.5</code>.</p> </li> <li> <p><code>max_solve_time</code></p> </li> <li>Format: <code>[time]</code></li> <li>Optional</li> <li>The maximum time to run the solver. Default is <code>None</code></li> </ul>"},{"location":"cli/inputfile/#example_9","title":"Example","text":"<pre><code>solver:\n  method: rosenbrock\n  t_span: [0.0, 1e10]\n  max_iter: 100\n  nevals: 200\n  dn_crit: 1e-3\n  dndt_crit: 1e-6\n  max_solve_time: 1 hour\n  enable_diffusion: false\n  rtol: 1e-2\n  atol: 1e-25\n</code></pre>"},{"location":"cli/inputfile/#vode","title":"Vode","text":"<p>The <code>vode</code> solver has the following additional properties:</p> <ul> <li><code>max_retries</code></li> <li>Format: <code>int</code></li> <li>Optional</li> <li>The maximum number of retries for the solver. Default is <code>10</code>.</li> <li><code>nevals</code></li> <li>Format: <code>int</code></li> <li>Optional</li> <li>The number of evaluations to store in the solution.</li> <li>These are evenly spaced in \\(\\log_{10}(t)\\).</li> <li>The results are interpolated to these points.</li> <li>Default is <code>200</code>.</li> </ul>"},{"location":"cli/inputfile/#example_10","title":"Example","text":"<pre><code>solver:\n  method: vode\n  t_span: [0.0, 1e10]\n  max_retries: 10\n  nevals: 200\n  dn_crit: 1e-3\n  dndt_crit: 1e-6\n  max_solve_time: 1 hour\n  enable_diffusion: false\n  rtol: 1e-2\n  atol: 1e-25\n</code></pre>"},{"location":"development/CONTRIBUTING/","title":"Contributing to <code>FRECKLL</code>","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"development/CONTRIBUTING/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"development/CONTRIBUTING/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/ahmed-f-alrefaie/FRECKLL/issues</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"development/CONTRIBUTING/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement a fix for it.</p>"},{"location":"development/CONTRIBUTING/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"development/CONTRIBUTING/#write-documentation","title":"Write Documentation","text":"<p>FRECKLL could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"development/CONTRIBUTING/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/ahmed-f-alrefaie/FRECKLL/issues.</p> <p>If you are proposing a new feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"development/CONTRIBUTING/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>FRECKLL</code> for local development. Please note this documentation assumes you already have <code>uv</code> and <code>Git</code> installed and ready to go.</p> <ol> <li> <p>Fork the <code>FRECKLL</code> repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> </li> </ol> <pre><code>cd &lt;directory_in_which_repo_should_be_created&gt;\ngit clone git@github.com:YOUR_NAME/FRECKLL.git\n</code></pre> <ol> <li>Now we need to install the environment. Navigate into the directory</li> </ol> <pre><code>cd FRECKLL\n</code></pre> <p>Then, install and activate the environment with:</p> <pre><code>uv sync\n</code></pre> <ol> <li>Install pre-commit to run linters/formatters at commit time:</li> </ol> <pre><code>uv run pre-commit install\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li> <p>Don't forget to add test cases for your added functionality to the <code>tests</code> directory.</p> </li> <li> <p>When you're done making changes, check that your changes pass the formatting tests.</p> </li> </ol> <pre><code>make check\n</code></pre> <p>Now, validate that all unit tests are passing:</p> <pre><code>make test\n</code></pre> <ol> <li>Before raising a pull request you should also run tox.    This will run the tests across different versions of Python:</li> </ol> <pre><code>tox\n</code></pre> <p>This requires you to have multiple versions of python installed. This step is also triggered in the CI/CD pipeline, so you could also choose to skip this step locally.</p> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"development/CONTRIBUTING/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li> <p>The pull request should include tests.</p> </li> <li> <p>If the pull request adds functionality, the docs should be updated.    Put your new functionality into a function with a docstring, and add the feature to the list in <code>README.md</code>.</p> </li> </ol>"},{"location":"development/codeofconduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"development/codeofconduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"development/codeofconduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"development/codeofconduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"development/codeofconduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"development/codeofconduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at ahmed-f-alrefaie. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"development/codeofconduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"modules/kinetics/","title":"Kinetics","text":"<p>Handles computing the kinetics of a reaction.</p>"},{"location":"modules/kinetics/#freckll.kinetics.air_density","title":"<code>air_density(temperature, pressure)</code>","text":"<p>Compute the density of the atmosphere.</p> <p>The air density of the atmosphere is given by:</p> \\[     \\rho = \\frac{P}{k_BT} \\] <p>Where \\(P\\) is the pressure, \\(k_B\\) is the Boltzmann constant, and \\(T\\) is the temperature.</p> Source code in <code>src/freckll/kinetics.py</code> <pre><code>def air_density(temperature: u.Quantity, pressure: u.Quantity) -&gt; u.Quantity:\n    r\"\"\"Compute the density of the atmosphere.\n\n    The *air* density of the atmosphere is given by:\n\n    $$\n        \\rho = \\frac{P}{k_BT}\n    $$\n\n    Where $P$ is the pressure, $k_B$ is the Boltzmann constant, and $T$ is the temperature.\n\n    \"\"\"\n    return pressure / (const.k_B * temperature)\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.alpha_term","title":"<code>alpha_term(species, vmr)</code>","text":"<p>Compute the thermal diffusion coefficient.</p> <p>The alpha term is given by:</p> \\[     \\alpha = \\frac{1}{\\sum_i \\frac{y_i}{\\mu_i}} \\] <p>Where \\(y_i\\) is the volume mixing ratio of species \\(i\\) and \\(\\mu_i\\) is the mean molecular weight of species \\(i\\).</p> <p>Parameters:</p> Name Type Description Default <code>species</code> <code>list[SpeciesFormula]</code> <p>The list of species.</p> required <code>vmr</code> <code>FreckllArray</code> <p>The volume mixing ratio.</p> required <p>Returns:</p> Type Description <code>FreckllArray</code> <p>The alpha term.</p> Source code in <code>src/freckll/kinetics.py</code> <pre><code>def alpha_term(species: list[SpeciesFormula], vmr: FreckllArray) -&gt; FreckllArray:\n    r\"\"\"Compute the thermal diffusion coefficient.\n\n    The alpha term is given by:\n\n    $$\n        \\alpha = \\frac{1}{\\sum_i \\frac{y_i}{\\mu_i}}\n    $$\n\n    Where $y_i$ is the volume mixing ratio of species $i$ and $\\mu_i$ is the mean molecular weight of species $i$.\n\n    Args:\n        species: The list of species.\n        vmr: The volume mixing ratio.\n\n    Returns:\n        The alpha term.\n    \"\"\"\n    alpha = np.full_like(vmr, 0.25)\n\n    if \"H\" in species:\n        index = species.index(\"H\")\n        alpha[index] = -0.1 * (1 - vmr[index])\n\n    if \"He\" in species:\n        index = species.index(\"He\")\n        alpha[index] = 0.145 * (1 - vmr[index])\n\n    if \"H2\" in species:\n        index = species.index(\"H2\")\n        alpha[index] = -0.38\n\n    return alpha\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.deltaz_terms","title":"<code>deltaz_terms(altitude)</code>","text":"<p>Compute the delta z terms. Computes the delta z terms for the finite difference scheme. The delta z terms are given by: $$     \\Delta z = z_{i+1} - z_i $$ $$     \\Delta z_{+} = z_{i+1} - z_i $$ $$     \\Delta z_{-} = z_i - z_{i-1} $$</p> <p>and the inverse delta z terms are given by: $$     \\frac{1}{\\Delta z} = \\frac{1}{z_{i+1} - z_i} $$ $$     \\frac{1}{\\Delta z_{+}} = \\frac{1}{z_{i+1} - z_i} $$ $$     \\frac{1}{\\Delta z_{-}} = \\frac{1}{z_i - z_{i-1}} $$</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Quantity</code> <p>The altitude</p> required <p>Returns:</p> Name Type Description <code>delta_z_plus</code> <code>FreckllArray</code> <p>The delta z plus term.</p> <code>delta_z_minus</code> <code>FreckllArray</code> <p>The delta z minus term.</p> <code>inv_dz</code> <code>FreckllArray</code> <p>The inverse delta z term.</p> <code>inv_dz_minus</code> <code>FreckllArray</code> <p>The inverse delta z minus term.</p> <code>inv_dz_plus</code> <code>FreckllArray</code> <p>The inverse delta z plus term.</p> Source code in <code>src/freckll/kinetics.py</code> <pre><code>def deltaz_terms(\n    altitude: u.Quantity,\n) -&gt; tuple[FreckllArray, FreckllArray, FreckllArray, FreckllArray, FreckllArray, FreckllArray]:\n    r\"\"\"Compute the delta z terms.\n    Computes the delta z terms for the finite difference scheme.\n    The delta z terms are given by:\n    $$\n        \\Delta z = z_{i+1} - z_i\n    $$\n    $$\n        \\Delta z_{+} = z_{i+1} - z_i\n    $$\n    $$\n        \\Delta z_{-} = z_i - z_{i-1}\n    $$\n\n    and the inverse delta z terms are given by:\n    $$\n        \\frac{1}{\\Delta z} = \\frac{1}{z_{i+1} - z_i}\n    $$\n    $$\n        \\frac{1}{\\Delta z_{+}} = \\frac{1}{z_{i+1} - z_i}\n    $$\n    $$\n        \\frac{1}{\\Delta z_{-}} = \\frac{1}{z_i - z_{i-1}}\n    $$\n\n\n    Args:\n        altitude: The altitude\n\n    Returns:\n        delta_z_plus: The delta z plus term.\n        delta_z_minus: The delta z minus term.\n        inv_dz: The inverse delta z term.\n        inv_dz_minus: The inverse delta z minus term.\n        inv_dz_plus: The inverse delta z plus term.\n\n\n    \"\"\"\n\n    delta_z = np.zeros_like(altitude)\n    delta_z_p = np.zeros_like(altitude)\n    delta_z_m = np.zeros_like(altitude)\n\n    delta_z_p[:-1] = altitude[1:] - altitude[:-1]\n    delta_z_m[1:] = altitude[1:] - altitude[:-1]\n\n    delta_z[:-1] = altitude[1:] - altitude[:-1]\n    delta_z[-1] = altitude[-1] - altitude[-2]\n    delta_z[0] = altitude[1] - altitude[0]\n\n    inv_dz = 1.0 / (0.5 * delta_z_p + 0.5 * delta_z_m)\n    inv_dz[0] = 1.0 / (delta_z[0])\n    inv_dz[-1] = 1.0 / (delta_z[-1])\n\n    inv_dz_m = 1.0 / (delta_z_m)\n    inv_dz_p = 1.0 / (delta_z_p)\n\n    return delta_z, delta_z_p, delta_z_m, inv_dz, inv_dz_p, inv_dz_m\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.diffusion_flux","title":"<code>diffusion_flux(vmr, density, planet_radius, planet_mass, altitude, temperature, mu, masses, molecular_diffusion, kzz)</code>","text":"<p>Compute the diffusion flux using finite difference.</p> <p>This is the term \\(\\frac{d \\phi}{dz}\\) term in the full kinetic equation where \\(\\phi\\) is the diffusion flux:</p> \\[ \\phi_i = -(D_i + K_{zz})n_t \\frac{dy_i}{dz} - D_in_t(\\frac{1}{H_0} - \\frac{1}{H_i}-\\frac{\\alpha_i}{T}\\frac{d T}{dz}) \\] <p>Where</p> <ul> <li>\\(D_i\\) is the diffusion coefficient for species \\(i\\),</li> <li>\\(K_{zz}\\) is the eddy diffusion coefficient,</li> <li>\\(n_t\\) is the total number density,</li> <li>\\(H_0\\) is the scale height of the atmosphere,</li> <li>\\(H_i\\) is the scale height of species \\(i\\),</li> <li>\\(\\alpha_i\\) is the thermal diffusion coefficient for species \\(i\\),</li> <li>\\(T\\) is the temperature,</li> <li>\\(y_i\\) is the volume mixing ratio of species \\(i\\),</li> </ul> <p>Parameters:</p> Name Type Description Default <code>vmr</code> <code>FreckllArray</code> <p>The volume mixing ratio.</p> required <code>density</code> <code>Quantity</code> <p>The density of the atmosphere.</p> required <code>planet_radius</code> <code>Quantity</code> <p>The radius of the planet.</p> required <code>planet_mass</code> <code>Quantity</code> <p>The mass of the planet.</p> required <code>altitude</code> <code>Quantity</code> <p>The altitude in km.</p> required <code>temperature</code> <code>Quantity</code> <p>The temperature in K.</p> required <code>mu</code> <code>Quantity</code> <p>The mean molecular weight in kg.</p> required <code>masses</code> <code>Quantity</code> <p>The molar masses in kg.</p> required <code>molecular_diffusion</code> <code>Quantity</code> <p>The molecular diffusion coefficient.</p> required <code>kzz</code> <code>Quantity</code> <p>The eddy diffusion coefficient.</p> required <p>Returns:     The diffusion flux. \\(\\frac{d \\phi}{dz}\\)</p> Source code in <code>src/freckll/kinetics.py</code> <pre><code>def diffusion_flux(\n    vmr: FreckllArray,\n    density: u.Quantity,\n    planet_radius: u.Quantity,\n    planet_mass: u.Quantity,\n    altitude: u.Quantity,\n    temperature: u.Quantity,\n    mu: u.Quantity,\n    masses: u.Quantity,\n    molecular_diffusion: u.Quantity,\n    kzz: u.Quantity,\n) -&gt; u.Quantity:\n    r\"\"\"Compute the diffusion flux using finite difference.\n\n    This is the term $\\frac{d \\phi}{dz}$ term in the full kinetic equation where $\\phi$ is the diffusion flux:\n\n    $$\n    \\phi_i = -(D_i + K_{zz})n_t \\frac{dy_i}{dz} - D_in_t(\\frac{1}{H_0} - \\frac{1}{H_i}-\\frac{\\alpha_i}{T}\\frac{d T}{dz})\n    $$\n\n    Where\n\n    - $D_i$ is the diffusion coefficient for species $i$,\n    - $K_{zz}$ is the eddy diffusion coefficient,\n    - $n_t$ is the total number density,\n    - $H_0$ is the scale height of the atmosphere,\n    - $H_i$ is the scale height of species $i$,\n    - $\\alpha_i$ is the thermal diffusion coefficient for species $i$,\n    - $T$ is the temperature,\n    - $y_i$ is the volume mixing ratio of species $i$,\n\n\n    Args:\n        vmr: The volume mixing ratio.\n        density: The density of the atmosphere.\n        planet_radius: The radius of the planet.\n        planet_mass: The mass of the planet.\n        altitude: The altitude in km.\n        temperature: The temperature in K.\n        mu: The mean molecular weight in kg.\n        masses: The molar masses in kg.\n        molecular_diffusion: The molecular diffusion coefficient.\n        kzz: The eddy diffusion coefficient.\n    Returns:\n        The diffusion flux. $\\frac{d \\phi}{dz}$\n\n\n\n    \"\"\"\n    # Compute the delta z terms\n    delta_z, delta_z_plus, delta_z_minus, inv_dz, inv_dz_plus, inv_dz_minus = deltaz_terms(altitude)\n\n    # Compute the diffusive terms\n    diffusion_plus, diffusion_minus = diffusive_terms(\n        planet_radius,\n        planet_mass,\n        altitude,\n        mu,\n        temperature,\n        masses,\n        delta_z,\n        delta_z_plus,\n        delta_z_minus,\n        inv_dz_plus,\n        inv_dz_minus,\n    )\n\n    # Compute the finite difference terms\n    fd_plus, fd_minus = finite_difference_terms(\n        altitude,\n        planet_radius,\n        inv_dz,\n        inv_dz_plus,\n        inv_dz_minus,\n    )\n\n    # Compute the VMR terms\n    dy_plus, dy_minus = vmr_terms(vmr, inv_dz_plus, inv_dz_minus)\n\n    # Compute the general plus and minus terms\n    dens_plus, dens_minus = general_plus_minus(density)\n    mdiff_plus, mdiff_minus = general_plus_minus(molecular_diffusion)\n    kzz_plus, kzz_minus = general_plus_minus(kzz)\n\n    diff_flux = np.zeros(vmr.shape) &lt;&lt; (1 / (u.cm**3 * u.s))\n\n    diff_flux[:, 1:-1] += (\n        dens_plus[1:-1]\n        * (\n            mdiff_plus[:, 1:-1] * ((vmr[:, 2:] + vmr[:, 1:-1]) * 0.5 * diffusion_plus[:, 1:-1] + dy_plus[:, 1:-1])\n            + kzz_plus[1:-1] * dy_plus[:, 1:-1]\n        )\n        * fd_plus[1:-1]\n        + dens_minus[1:-1]\n        * (\n            mdiff_minus[:, 1:-1] * ((vmr[:, 1:-1] + vmr[:, :-2]) * 0.5 * diffusion_minus[:, 1:-1] + dy_minus[:, 1:-1])\n            + kzz_minus[1:-1] * dy_minus[:, 1:-1]\n        )\n        * fd_minus[1:-1]\n    )\n    diff_flux[:, 0] += (\n        dens_plus[0]\n        * (\n            mdiff_plus[:, 0] * ((vmr[:, 1] + vmr[:, 0]) * 0.5 * diffusion_plus[:, 0] + dy_plus[:, 0])\n            + kzz_plus[0] * dy_plus[:, 0]\n        )\n        * fd_plus[0]\n    )\n    diff_flux[:, -1] += (\n        fd_minus[-1]\n        * dens_minus[-1]\n        * (\n            mdiff_minus[:, -1] * ((vmr[:, -1] + vmr[:, -2]) * 0.5 * diffusion_minus[:, -1] + dy_minus[:, -1])\n            + kzz_minus[-1] * dy_minus[:, -1]\n        )\n    )\n\n    return diff_flux\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.diffusive_terms","title":"<code>diffusive_terms(planet_radius, planet_mass, altitude, mu, temperature, masses, delta_z, delta_z_plus, delta_z_minus, inv_dz_plus, inv_dz_minus, alpha=0.0)</code>","text":"<p>Compute the diffusive term.</p> <p>Computes the staggered gridpoints for the diffusive term.</p> <p>We use the following finite difference scheme:</p> \\[ \\frac{\\partial}{\\partial z}\\left(\\frac{1}{H}\\frac{\\partial y}{\\partial z}\\right) \\] <p>Parameters:</p> Name Type Description Default <code>planet_radius</code> <code>Quantity</code> <p>Radius of planet in kilometers.</p> required <code>planet_mass</code> <code>Quantity</code> <p>Mass of planet in kg.</p> required <code>altitude</code> <code>Quantity</code> <p>The altitude in km.</p> required <code>mu</code> <code>Quantity</code> <p>The mean molecular weight in kg.</p> required <code>temperature</code> <code>Quantity</code> <p>The temperature in K.</p> required <code>masses</code> <code>Quantity</code> <p>The molar masses in kg.</p> required <code>delta_z</code> <code>Quantity</code> <p>The delta z term.</p> required <code>delta_z_plus</code> <code>Quantity</code> <p>The delta z plus term.</p> required <code>delta_z_minus</code> <code>Quantity</code> <p>The delta z minus term.</p> required <code>inv_dz_plus</code> <code>Quantity</code> <p>The inverse delta z plus term.</p> required <code>inv_dz_minus</code> <code>Quantity</code> <p>The inverse delta z minus term.</p> required <code>alpha</code> <code>float</code> <p>The alpha parameter to include temperature term.</p> <code>0.0</code> Source code in <code>src/freckll/kinetics.py</code> <pre><code>def diffusive_terms(\n    planet_radius: u.Quantity,\n    planet_mass: u.Quantity,\n    altitude: u.Quantity,\n    mu: u.Quantity,\n    temperature: u.Quantity,\n    masses: u.Quantity,\n    delta_z: u.Quantity,\n    delta_z_plus: u.Quantity,\n    delta_z_minus: u.Quantity,\n    inv_dz_plus: u.Quantity,\n    inv_dz_minus: u.Quantity,\n    alpha: float = 0.0,\n) -&gt; tuple[u.Quantity, u.Quantity]:\n    r\"\"\"Compute the diffusive term.\n\n    Computes the staggered gridpoints for the diffusive term.\n\n    We use the following finite difference scheme:\n\n    $$\n    \\frac{\\partial}{\\partial z}\\left(\\frac{1}{H}\\frac{\\partial y}{\\partial z}\\right)\n    $$\n\n    Args:\n        planet_radius: Radius of planet in kilometers.\n        planet_mass: Mass of planet in kg.\n        altitude: The altitude in km.\n        mu: The mean molecular weight in kg.\n        temperature: The temperature in K.\n        masses: The molar masses in kg.\n        delta_z: The delta z term.\n        delta_z_plus: The delta z plus term.\n        delta_z_minus: The delta z minus term.\n        inv_dz_plus: The inverse delta z plus term.\n        inv_dz_minus: The inverse delta z minus term.\n        alpha: The alpha parameter to include temperature term.\n\n    \"\"\"\n\n    # cm/m2\n    central_g = gravity_at_height(planet_mass, planet_radius, altitude)\n    plus_g = gravity_at_height(planet_mass, planet_radius, altitude + delta_z_plus)\n    minus_g = gravity_at_height(planet_mass, planet_radius, altitude - delta_z_minus)\n\n    # total scaleheight\n    h_total = scaleheight(temperature, central_g, mu)\n    h_mass = scaleheight(temperature, central_g, masses[:, None])\n\n    h_total_plus = np.zeros_like(h_total) &lt;&lt; h_total.unit\n    h_total_minus = np.zeros_like(h_total) &lt;&lt; h_total.unit\n    h_mass_plus = np.zeros_like(h_mass) &lt;&lt; h_mass.unit\n    h_mass_minus = np.zeros_like(h_mass) &lt;&lt; h_mass.unit\n\n    h_total_plus[:-1] = scaleheight(\n        temperature[1:],\n        plus_g[:-1],\n        mu[1:],\n    )\n\n    h_total_minus[1:] = scaleheight(\n        temperature[:-1],\n        minus_g[1:],\n        mu[:-1],\n    )\n\n    h_mass_plus[..., :-1] = scaleheight(\n        temperature[1:],\n        plus_g[:-1],\n        masses[:, None],\n    )\n\n    h_mass_minus[..., 1:] = scaleheight(\n        temperature[:-1],\n        minus_g[1:],\n        masses[:, None],\n    )\n\n    # ----- Diffusive flux -----\n\n    # temperature terms\n    temperature_factor = (temperature[1:] - temperature[:-1]) / (temperature[1:] + temperature[:-1])\n    t_diffusion_plus = 2.0 * alpha * inv_dz_plus[:-1] * temperature_factor\n    t_diffusion_minus = 2.0 * alpha * inv_dz_minus[1:] * temperature_factor\n\n    #    diffusion_plus[:, :-1] = (\n    #         2.0 / (hip[:, :-1] + hi[:, :-1]) - 2.0 / (hap[:-1] + ha[:-1])\n    #     ) + 2.0 * alpha * inv_dz_p[:-1] * (T[1:] - T[:-1]) / (T[1:] + T[:-1])\n\n    diffusion_plus = 2 / (h_mass_plus + h_mass) - 2 / (h_total_plus + h_total)\n    diffusion_minus = 2 / (h_mass_minus + h_mass) - 2 / (h_total_minus + h_total)\n\n    diffusion_plus[..., :-1] += t_diffusion_plus\n    diffusion_minus[..., 1:] += t_diffusion_minus\n\n    diffusion_plus[..., -1] = 1 / h_mass[..., -1] - 1 / h_total[-1]\n    diffusion_minus[..., 0] = 1 / h_mass[..., 0] - 1 / h_total[0]\n\n    return (\n        diffusion_plus,\n        diffusion_minus,\n    )\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.finite_difference_terms","title":"<code>finite_difference_terms(altitude, radius, inv_dz, inv_dz_plus, inv_dz_minus)</code>","text":"<p>Compute finite difference terms.</p> <p>Computes the finite difference terms for the diffusion flux. The finite difference terms are given by:</p> \\[\\begin{align}    c^{+} &amp;= \\frac{(1 + \\frac{0.5 \\Delta z}{R + z})^2}{\\Delta z}\\\\    c^{-} &amp;= -\\frac{(1 - \\frac{0.5 \\Delta z}{R + z})^2}{\\Delta z} \\end{align}\\] <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Quantity</code> <p>Altitude in km.</p> required <code>radius</code> <code>float</code> <p>Radius of the planet in km.</p> required <code>inv_dz</code> <code>Quantity</code> <p>The inverse delta z term in cm^-1.</p> required <code>inv_dz_plus</code> <code>Quantity</code> <p>The inverse delta z plus term in cm^-1.</p> required <code>inv_dz_minus</code> <code>Quantity</code> <p>The inverse delta z minus term in cm^-1.</p> required Source code in <code>src/freckll/kinetics.py</code> <pre><code>def finite_difference_terms(\n    altitude: u.Quantity,\n    radius: float,\n    inv_dz: u.Quantity,\n    inv_dz_plus: u.Quantity,\n    inv_dz_minus: u.Quantity,\n) -&gt; tuple[u.Quantity, u.Quantity]:\n    r\"\"\"Compute finite difference terms.\n\n\n    Computes the finite difference terms for the diffusion flux.\n    The finite difference terms are given by:\n\n    \\begin{align}\n       c^{+} &amp;= \\frac{(1 + \\frac{0.5 \\Delta z}{R + z})^2}{\\Delta z}\\\\\n       c^{-} &amp;= -\\frac{(1 - \\frac{0.5 \\Delta z}{R + z})^2}{\\Delta z}\n    \\end{align}\n\n\n    Args:\n        altitude: Altitude in km.\n        radius: Radius of the planet in km.\n        inv_dz: The inverse delta z term in cm^-1.\n        inv_dz_plus: The inverse delta z plus term in cm^-1.\n        inv_dz_minus: The inverse delta z minus term in cm^-1.\n    \"\"\"\n    fd_plus = (1 + 0.5 / ((radius + altitude) * inv_dz_plus)) ** 2 * inv_dz\n    fd_minus = -((1 - 0.5 / ((radius + altitude) * inv_dz_minus)) ** 2) * inv_dz\n\n    # Handle boundaries\n    fd_minus[0] = -((1 - 0.5 / ((radius + altitude[0]) * inv_dz[0])) ** 2) * inv_dz[0]\n    fd_plus[-1] = (1 + 0.5 / ((radius + altitude[-1]) * inv_dz[-1])) ** 2 * inv_dz[-1]\n\n    return fd_plus, fd_minus\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.general_plus_minus","title":"<code>general_plus_minus(array)</code>","text":"<p>Compute the plus and minus terms.</p> <p>Computes general plus minus terms</p> <p>Generally defined as: $$    a_{+} = \\frac{1}{2} \\left( a_{i+1} + a_{i} \\right) $$ $$    a_{-} = \\frac{1}{2} \\left( a_{i} + a_{i-1} \\right) $$ Where \\(a\\) is the array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Quantity</code> <p>The array to compute the plus and minus terms.</p> required <p>Returns:</p> Name Type Description <code>plus</code> <code>Quantity</code> <p>The plus term.</p> <code>minus</code> <code>Quantity</code> <p>The minus term.</p> Source code in <code>src/freckll/kinetics.py</code> <pre><code>def general_plus_minus(\n    array: u.Quantity,\n) -&gt; tuple[u.Quantity, u.Quantity]:\n    r\"\"\"Compute the plus and minus terms.\n\n    Computes general plus minus terms\n\n    Generally defined as:\n    $$\n       a_{+} = \\frac{1}{2} \\left( a_{i+1} + a_{i} \\right)\n    $$\n    $$\n       a_{-} = \\frac{1}{2} \\left( a_{i} + a_{i-1} \\right)\n    $$\n    Where $a$ is the array.\n\n\n    Args:\n        array: The array to compute the plus and minus terms.\n\n    Returns:\n        plus: The plus term.\n        minus: The minus term.\n    \"\"\"\n\n    sum_arr = array[..., :-1] + array[..., 1:]\n\n    plus = np.zeros_like(array) &lt;&lt; array.unit\n    minus = np.zeros_like(array) &lt;&lt; array.unit\n\n    plus[..., :-1] = sum_arr\n    minus[..., 1:] = sum_arr\n    plus[..., -1] = sum_arr[..., -1]\n    minus[..., 0] = sum_arr[..., 0]\n\n    return 0.5 * plus, 0.5 * minus\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.gravity_at_height","title":"<code>gravity_at_height(mass, radius, altitude)</code>","text":"<p>Compute the gravity at a given altitude.</p> <p>The gravity at a given altitude is given by:</p> \\[     g = \\frac{Gm}{r^2} \\] <p>Where \\(G\\) is the gravitational constant, \\(m\\) is the mass of the planet, and \\(r\\) is the radius of the planet.</p> <p>Parameters:</p> Name Type Description Default <code>mass</code> <code>Quantity</code> <p>The mass of the planet.</p> required <code>radius</code> <code>Quantity</code> <p>The radius of the planet.</p> required <code>altitude</code> <code>Quantity</code> <p>The altitude at which to compute the gravity.</p> required Source code in <code>src/freckll/kinetics.py</code> <pre><code>def gravity_at_height(mass: u.Quantity, radius: u.Quantity, altitude: u.Quantity) -&gt; u.Quantity:\n    r\"\"\"Compute the gravity at a given altitude.\n\n    The gravity at a given altitude is given by:\n\n    $$\n        g = \\frac{Gm}{r^2}\n    $$\n\n    Where $G$ is the gravitational constant, $m$ is the mass of the planet,\n    and $r$ is the radius of the planet.\n\n    Args:\n        mass: The mass of the planet.\n        radius: The radius of the planet.\n        altitude: The altitude at which to compute the gravity.\n\n    \"\"\"\n    return const.G * mass / (radius + altitude) ** 2\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.scaleheight","title":"<code>scaleheight(temperature, gravity, mass)</code>","text":"<p>Compute the scale height of the atmosphere.</p> <p>The scale height is given by:</p> \\[     H = \\frac{k_BT}{mg} \\] <p>Where \\(k_B\\) is the Boltzmann constant, \\(T\\) is the temperature, \\(m\\) is the molar mass, and \\(g\\) is the gravity.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>Quantity</code> <p>The temperature.</p> required <code>gravity</code> <code>Quantity</code> <p>The gravity at a given altitude.</p> required <code>mass</code> <code>Quantity</code> <p>Mass .</p> required Source code in <code>src/freckll/kinetics.py</code> <pre><code>def scaleheight(temperature: u.Quantity, gravity: u.Quantity, mass: u.Quantity) -&gt; u.Quantity:\n    r\"\"\"Compute the scale height of the atmosphere.\n\n    The scale height is given by:\n\n    $$\n        H = \\frac{k_BT}{mg}\n    $$\n\n    Where $k_B$ is the Boltzmann constant, $T$ is the temperature,\n    $m$ is the molar mass, and $g$ is the gravity.\n\n    Args:\n        temperature: The temperature.\n        gravity: The gravity at a given altitude.\n        mass: Mass .\n\n    \"\"\"\n    return const.k_B * temperature / (mass * gravity)\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.solve_altitude_profile","title":"<code>solve_altitude_profile(temperature, mu, pressures, planet_mass, planet_radius)</code>","text":"<p>Solve altitude corresponding to given pressure levels.</p> <p>Solves the hydrostatic equilibrium equation to compute the altitude corresponding to the given pressure levels.</p> \\[ \\frac{dz}{dP} = -\\frac{1}{\\rho g} \\] <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>Quantity</code> <p>Temperature profile as a function of pressure.</p> required <code>mu</code> <code>Quantity</code> <p>Mean molecular weight profile as a function of pressure.</p> required <code>pressures</code> <code>Quantity</code> <p>Pressure levels.</p> required <code>planet_mass</code> <code>Quantity</code> <p>Mass of the planet.</p> required <code>planet_radius</code> <code>Quantity</code> <p>Radius of the planet.</p> required <p>Returns:</p> Type Description <code>Quantity</code> <p>Altitude profile corresponding to the given pressure</p> Source code in <code>src/freckll/kinetics.py</code> <pre><code>def solve_altitude_profile(\n    temperature: u.Quantity, mu: u.Quantity, pressures: u.Quantity, planet_mass: u.Quantity, planet_radius: u.Quantity\n) -&gt; u.Quantity:\n    r\"\"\"Solve altitude corresponding to given pressure levels.\n\n    Solves the hydrostatic equilibrium equation to compute the altitude corresponding to the given pressure levels.\n\n    $$\n    \\frac{dz}{dP} = -\\frac{1}{\\rho g}\n    $$\n\n\n    Args:\n        temperature: Temperature profile as a function of pressure.\n        mu: Mean molecular weight profile as a function of pressure.\n        pressures: Pressure levels.\n        planet_mass: Mass of the planet.\n        planet_radius: Radius of the planet.\n\n    Returns:\n        Altitude profile corresponding to the given pressure\n    \"\"\"\n    from astropy import constants as const\n    from scipy.integrate import solve_ivp\n    from scipy.interpolate import interp1d\n\n    G = const.G.value\n\n    density = (air_density(temperature, pressures) * mu).to(u.kg / u.m**3).value\n\n    planet_mass = planet_mass.to(u.kg).value\n    planet_radius = planet_radius.to(u.m).value\n    pressures = pressures.to(u.Pa).value\n    # Ensure pressure is in decreasing order for interpolation\n    sort_idx = np.argsort(pressures)[::-1]\n    pressures_sorted = pressures[sort_idx]\n    density_sorted = density[sort_idx]\n\n    # Create interpolators for T(P) and mu(P)\n    rho_interp = interp1d(pressures_sorted, density_sorted, kind=\"linear\", copy=False, fill_value=\"extrapolate\")\n\n    # Define the ODE function dz/dP\n    def dzdP(P, z):\n        rho = rho_interp(P)\n\n        g = G * planet_mass / (planet_radius + z) ** 2\n        return -1.0 / (rho * g)\n\n    P_surface = pressures_sorted[0]\n\n    # Integrate from P_surface down to the minimum pressure in the data\n    P_min = pressures_sorted.min()\n    P_span = (P_surface, P_min)\n    initial_z = [0.0]  # Starting altitude at surface\n\n    # Solve the ODE\n    sol = solve_ivp(dzdP, P_span, initial_z, dense_output=True)\n    if sol.success is False:\n        raise AltitudeSolveError\n    # Generate altitude at the original pressure points (interpolate if necessary)\n    # Reverse pressures to increasing order for interpolation\n    P_eval = np.sort(pressures)\n    z_eval = sol.sol(P_eval)[0]\n\n    # Ensure altitudes are in the same order as input pressures\n    return z_eval[np.argsort(sort_idx)][::-1] &lt;&lt; u.m\n</code></pre>"},{"location":"modules/kinetics/#freckll.kinetics.vmr_terms","title":"<code>vmr_terms(vmr, inv_dz_plus, inv_dz_minus)</code>","text":"<p>Compute the VMR terms.</p> <p>this is the finite difference term for the VMR.</p> \\[ \\frac{dy}{dz} \\] <p>Parameters:</p> Name Type Description Default <code>vmr</code> <code>FreckllArray</code> <p>The volume mixing ratio.</p> required <code>inv_dz_plus</code> <code>Quantity</code> <p>The inverse delta z plus term.</p> required <code>inv_dz_minus</code> <code>Quantity</code> <p>The inverse delta z minus term.</p> required Source code in <code>src/freckll/kinetics.py</code> <pre><code>def vmr_terms(\n    vmr: FreckllArray, inv_dz_plus: u.Quantity, inv_dz_minus: u.Quantity\n) -&gt; tuple[FreckllArray, FreckllArray]:\n    r\"\"\"Compute the VMR terms.\n\n    this is the finite difference term for the VMR.\n\n    $$\n    \\frac{dy}{dz}\n    $$\n\n    Args:\n        vmr: The volume mixing ratio.\n        inv_dz_plus: The inverse delta z plus term.\n        inv_dz_minus: The inverse delta z minus term.\n\n    \"\"\"\n    vmr_diff = np.diff(vmr, axis=-1)\n    dy_plus = np.zeros(vmr.shape) &lt;&lt; inv_dz_plus.unit\n    dy_minus = np.zeros(vmr.shape) &lt;&lt; inv_dz_minus.unit\n    dy_plus[:, :-1] = (vmr_diff) * inv_dz_plus[:-1]\n    dy_minus[:, 1:] = (vmr_diff) * inv_dz_minus[1:]\n\n    return dy_plus, dy_minus\n</code></pre>"},{"location":"modules/ode/","title":"ODE","text":"<p>Module to construct the ODE system for the Freckll model.</p>"},{"location":"modules/ode/#freckll.ode.construct_jacobian_reaction_terms","title":"<code>construct_jacobian_reaction_terms(loss_reactions, species, number_density, k=4)</code>","text":"<p>Construct the Jacobian for the reaction terms.</p> <p>Parameters:</p> Name Type Description Default <code>loss_reactions</code> <code>SpeciesDict[list[Reaction]]</code> <p>The loss reactions for the species.</p> required <code>species</code> <code>list[SpeciesFormula]</code> <p>The list of species.</p> required <code>number_density</code> <code>FreckllArray</code> <p>The number density of the species.</p> required <code>k</code> <code>int</code> <p>K-sum number (higher is more accurate)</p> <code>4</code> Source code in <code>src/freckll/ode.py</code> <pre><code>def construct_jacobian_reaction_terms(\n    loss_reactions: SpeciesDict[list[Reaction]],\n    species: list[SpeciesFormula],\n    number_density: FreckllArray,\n    k: int = 4,\n) -&gt; tuple[list[FreckllArrayInt], list[FreckllArrayInt], FreckllArray]:\n    \"\"\"Construct the Jacobian for the reaction terms.\n\n    Args:\n        loss_reactions: The loss reactions for the species.\n        species: The list of species.\n        number_density: The number density of the species.\n        k: K-sum number (higher is more accurate)\n\n    \"\"\"\n    from collections import defaultdict\n\n    # Construct the reaction terms\n    # df/dn dR/dn =\n\n    rows = []\n    cols = []\n    data = []\n\n    num_species = len(species)\n\n    atmos_shape = number_density.shape\n\n    num_layers = atmos_shape[1]\n\n    layer_idx = np.arange(num_layers)\n\n    for spec_idx, spec in enumerate(species):\n        spec_density = number_density[spec_idx]\n        all_reactions = loss_reactions.get(spec, [])\n        if not all_reactions:\n            continue\n\n        chem_dict = defaultdict(list)\n        for _react_idx, r in enumerate(all_reactions):\n            for p in r.product_indices:\n                chem_dict[p].append(r.dens_krate)\n            for p in r.reactants_indices:\n                chem_dict[p].append(-r.dens_krate)\n\n        if not chem_dict:\n            continue\n\n        row_idx = compute_index(spec_idx, layer_idx, num_species, num_layers)\n        for p, v in chem_dict.items():\n            reaction_term = ksum(np.array(v), k=k) / spec_density\n            col_idx = compute_index(p, layer_idx, num_species, num_layers)\n            rows.append(row_idx)\n            cols.append(col_idx)\n            data.append(reaction_term)\n    return np.concatenate(rows), np.concatenate(cols), np.concatenate(data)\n</code></pre>"},{"location":"modules/ode/#freckll.ode.construct_jacobian_vertical_terms","title":"<code>construct_jacobian_vertical_terms(density, planet_radius, planet_mass, altitude, temperature, mu, masses, molecular_diffusion, kzz)</code>","text":"<p>Construct the Jacobian for the vertical terms.</p> Source code in <code>src/freckll/ode.py</code> <pre><code>def construct_jacobian_vertical_terms(\n    density: u.Quantity,\n    planet_radius: float,\n    planet_mass: float,\n    altitude: u.Quantity,\n    temperature: u.Quantity,\n    mu: u.Quantity,\n    masses: u.Quantity,\n    molecular_diffusion: u.Quantity,\n    kzz: u.Quantity,\n):\n    \"\"\"Construct the Jacobian for the vertical terms.\"\"\"\n    from freckll import kinetics\n\n    atmos_shape = masses.shape + mu.shape\n    with np.errstate(all=\"ignore\"):\n        delta_z, delta_z_plus, delta_z_minus, inv_dz, inv_dz_plus, inv_dz_minus = kinetics.deltaz_terms(altitude)\n\n        fd_plus, fd_minus = kinetics.finite_difference_terms(\n            altitude,\n            planet_radius,\n            inv_dz,\n            inv_dz_plus,\n            inv_dz_minus,\n        )\n\n        diffusion_plus, diffusion_minus = kinetics.diffusive_terms(\n            planet_radius,\n            planet_mass,\n            altitude,\n            mu,\n            temperature,\n            masses,\n            delta_z,\n            delta_z_plus,\n            delta_z_minus,\n            inv_dz_plus,\n            inv_dz_minus,\n        )\n\n        dens_plus, dens_minus = kinetics.general_plus_minus(density)\n        mdiff_plus, mdiff_minus = kinetics.general_plus_minus(molecular_diffusion)\n        kzz_plus, kzz_minus = kinetics.general_plus_minus(kzz)\n\n        pd_same_p = dens_plus * (mdiff_plus * (0.5 * diffusion_plus - inv_dz_plus) - inv_dz_plus * kzz_plus) * fd_plus\n\n        pd_same_m = (\n            dens_minus * (mdiff_minus * (0.5 * diffusion_minus + inv_dz_minus) + inv_dz_minus * kzz_minus) * fd_minus\n        )\n\n        pd_same = pd_same_p + pd_same_m\n        pd_p = dens_minus * (mdiff_minus * (0.5 * diffusion_minus - inv_dz_minus) - inv_dz_minus * kzz_minus) * fd_minus\n        pd_m = dens_plus * (mdiff_plus * (0.5 * diffusion_plus + inv_dz_plus) + inv_dz_plus * kzz_plus) * fd_plus\n\n        pd_same[:, 0] = (\n            dens_plus[0]\n            * (mdiff_plus[:, 0] * (0.5 * diffusion_plus[:, 0] - inv_dz[0]) - inv_dz[0] * kzz_plus[0])\n            * fd_plus[0]\n        )\n\n        pd_m[:, 0] = (\n            dens_plus[0]\n            * (mdiff_plus[:, 0] * (0.5 * diffusion_plus[:, 0] + inv_dz[0]) + inv_dz[0] * kzz_plus[0])\n            * fd_plus[0]\n        )\n\n        pd_same[:, -1] = (\n            dens_minus[-1]\n            * (mdiff_minus[:, -1] * (0.5 * diffusion_minus[:, -1] + inv_dz[-1]) + inv_dz[-1] * kzz_minus[-1])\n            * fd_minus[-1]\n        )\n\n        pd_p[:, -1] = (\n            dens_minus[-1]\n            * (mdiff_minus[:, -1] * (0.5 * diffusion_minus[:, -1] - inv_dz[-1]) - inv_dz[-1] * kzz_minus[-1])\n            * fd_minus[-1]\n        )\n        # pd_p[:,-1] =  pd_same[:, -1]\n        # pd_p[:, 0] = 0.0\n        # pd_m[:, 0] = pd_same[:, 0]\n        # pd_m[:, -1] = 0.0\n\n        # Now its time to construct the Jacobian\n        pd_same /= density\n        pd_p /= density\n        pd_m /= density\n\n    pd_same = pd_same.decompose().value\n    pd_p = pd_p.decompose().value\n    pd_m = pd_m.decompose().value\n\n    num_species, num_layers = pd_same.shape\n\n    rows = []\n    columns = []\n\n    data = []\n\n    same_layer = np.arange(0, num_layers)\n    plus_one = np.arange(1, num_layers)\n    minus_one = np.arange(0, num_layers - 1)\n\n    for x in range(num_species):\n        spec_index = compute_index(x, same_layer, num_species, num_layers)\n        rows.append(spec_index)\n        columns.append(spec_index)\n        data.append(pd_same[x])\n\n        plus_index = compute_index(x, plus_one, num_species, num_layers)\n        minus_index = compute_index(x, minus_one, num_species, num_layers)\n\n        rows.append(spec_index[1:])\n        columns.append(minus_index)\n        data.append(pd_m[x, :-1])\n\n        rows.append(spec_index[:-1])\n        columns.append(plus_index)\n        data.append(pd_p[x, 1:])\n\n    return np.concatenate(rows), np.concatenate(columns), np.concatenate(data)\n</code></pre>"},{"location":"modules/ode/#freckll.ode.construct_reaction_terms","title":"<code>construct_reaction_terms(production_reactions, loss_reactions, species, num_layers, k=4)</code>","text":"<p>Construct all of the reaction terms.</p> Source code in <code>src/freckll/ode.py</code> <pre><code>def construct_reaction_terms(\n    production_reactions: SpeciesDict[list[Reaction]],\n    loss_reactions: SpeciesDict[list[Reaction]],\n    species: list[SpeciesFormula],\n    num_layers: int,\n    k: int = 4,\n) -&gt; FreckllArray:\n    \"\"\"Construct all of the reaction terms.\"\"\"\n\n    reaction_terms = np.zeros((len(species), num_layers), dtype=np.float64)\n\n    for spec_idx, spec in enumerate(species):\n        production_spec = production_reactions.get(spec, [])\n        loss_spec = loss_reactions.get(spec, [])\n        productions = [p.dens_krate for p in production_spec]\n        losses = [-ls.dens_krate for ls in loss_spec]\n\n        all_reactions = productions + losses\n\n        if not all_reactions:\n            continue\n\n        reaction_terms[spec_idx] = ksum(np.array(all_reactions), k=k)\n\n    # reaction_terms = np.zeros(\n    #     (len(reactions), num_species, num_layers), dtype=np.float64\n    # )\n    # for idx, r in enumerate(reactions):\n    #     reaction_terms[idx, r.product_indices] = r.dens_krate\n    #     reaction_terms[idx, r.reactants_indices] -= r.dens_krate\n\n    return reaction_terms\n</code></pre>"},{"location":"modules/ode/#freckll.ode.construct_vertical_jacobian","title":"<code>construct_vertical_jacobian(vmr, density, planet_radius, planet_mass, altitude, temperature, mu, masses, molecular_diffusion, kzz)</code>","text":"<p>Compute the diffusion flux using finite difference.</p> <p>This is the term:</p> \\[ \\frac{d \\pi}{dz} \\] Source code in <code>src/freckll/ode.py</code> <pre><code>def construct_vertical_jacobian(\n    vmr: FreckllArray,\n    density: u.Quantity,\n    planet_radius: u.Quantity,\n    planet_mass: u.Quantity,\n    altitude: u.Quantity,\n    temperature: u.Quantity,\n    mu: u.Quantity,\n    masses: u.Quantity,\n    molecular_diffusion: u.Quantity,\n    kzz: u.Quantity,\n) -&gt; u.Quantity:\n    r\"\"\"Compute the diffusion flux using finite difference.\n\n    This is the term:\n\n    $$\n    \\frac{d \\pi}{dz}\n    $$\n    \"\"\"\n    from scipy.sparse import csc_matrix\n\n    from freckll.kinetics import deltaz_terms, diffusive_terms, finite_difference_terms, general_plus_minus\n\n    # Compute the delta z terms\n    delta_z, delta_z_plus, delta_z_minus, inv_dz, inv_dz_plus, inv_dz_minus = deltaz_terms(altitude)\n\n    # Compute the diffusive terms\n    diffusion_plus, diffusion_minus = diffusive_terms(\n        planet_radius,\n        planet_mass,\n        altitude,\n        mu,\n        temperature,\n        masses,\n        delta_z,\n        delta_z_plus,\n        delta_z_minus,\n        inv_dz_plus,\n        inv_dz_minus,\n    )\n\n    # Compute the finite difference terms\n    fd_plus, fd_minus = finite_difference_terms(\n        altitude,\n        planet_radius,\n        inv_dz,\n        inv_dz_plus,\n        inv_dz_minus,\n    )\n\n    # Compute the general plus and minus terms\n    dens_plus, dens_minus = general_plus_minus(density)\n    mdiff_plus, mdiff_minus = general_plus_minus(molecular_diffusion)\n    kzz_plus, kzz_minus = general_plus_minus(kzz)\n    pd_same_p = dens_plus * (mdiff_plus * (0.5 * diffusion_plus - inv_dz_plus) - inv_dz_plus * kzz_plus) * fd_plus\n\n    pd_same_m = (\n        dens_minus * (mdiff_minus * (0.5 * diffusion_minus + inv_dz_minus) + inv_dz_minus * kzz_minus) * fd_minus\n    )\n\n    pd_same = pd_same_p + pd_same_m\n    pd_p = dens_minus * (mdiff_minus * (0.5 * diffusion_minus - inv_dz_minus) - inv_dz_minus * kzz_minus) * fd_minus\n    pd_m = dens_plus * (mdiff_plus * (0.5 * diffusion_plus + inv_dz_plus) + inv_dz_plus * kzz_plus) * fd_plus\n\n    pd_same[:, 0] = (\n        dens_plus[0]\n        * (mdiff_plus[:, 0] * (0.5 * diffusion_plus[:, 0] - inv_dz[0]) - inv_dz[0] * kzz_plus[0])\n        * fd_plus[0]\n    )\n\n    pd_m[:, 0] = (\n        dens_plus[0]\n        * (mdiff_plus[:, 0] * (0.5 * diffusion_plus[:, 0] + inv_dz[0]) + inv_dz[0] * kzz_plus[0])\n        * fd_plus[0]\n    )\n\n    pd_same[:, -1] = (\n        dens_minus[-1]\n        * (mdiff_minus[:, -1] * (0.5 * diffusion_minus[:, -1] + inv_dz[-1]) + inv_dz[-1] * kzz_minus[-1])\n        * fd_minus[-1]\n    )\n\n    pd_p[:, -1] = (\n        dens_minus[-1]\n        * (mdiff_minus[:, -1] * (0.5 * diffusion_minus[:, -1] - inv_dz[-1]) - inv_dz[-1] * kzz_minus[-1])\n        * fd_minus[-1]\n    )\n    # pd_p[:,-1] =  pd_same[:, -1]\n\n    # pd_m[:,:-1]/=density[1:]\n    pd_same = (pd_same / density).to(1 / u.s).value\n\n    pd_p = (pd_p / density).to(1 / u.s).value\n\n    pd_m = (pd_m / density).to(1 / u.s).value\n\n    num_species, num_layers = pd_same.shape\n    same_layer = np.arange(0, num_layers)\n    plus_one = np.arange(1, num_layers)\n    minus_one = np.arange(0, num_layers - 1)\n\n    neq = num_species * num_layers\n\n    rows = []\n    cols = []\n    data = []\n    for x in range(num_species):\n        species_index = compute_index(x, same_layer, num_species, num_layers)\n        rows.append(species_index)\n        cols.append(species_index)\n        data.append(pd_same[x, :])\n\n        plus_index = compute_index(x, plus_one, num_species, num_layers)\n        minus_index = compute_index(x, minus_one, num_species, num_layers)\n        rows.append(species_index[1:])\n        cols.append(minus_index)\n        data.append(pd_m[x, :-1])\n\n        rows.append(species_index[:-1])\n        cols.append(plus_index)\n        data.append(pd_p[x, 1:])\n    rows = np.concatenate(rows)\n    cols = np.concatenate(cols)\n    data = np.concatenate(data)\n    return csc_matrix((data, (cols, rows)), shape=(neq, neq))\n</code></pre>"},{"location":"modules/io/loader/","title":"Loader","text":"<p>Parse FRECKLL input file.</p>"},{"location":"modules/io/loader/#freckll.io.loader.ace_equil_chemistry_loader","title":"<code>ace_equil_chemistry_loader(*, species, temperature, pressure, therm_file=None, elements=('H', 'He', 'C', 'N', 'O'), abundances=(12, 10.93, 8.39, 7.86, 8.73), **kwargs)</code>","text":"<p>Loads and runs the ACE chemistry model.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def ace_equil_chemistry_loader(\n    *,\n    species: list[SpeciesFormula],\n    temperature: u.Quantity,\n    pressure: u.Quantity,\n    therm_file: t.Optional[pathlib.Path] = None,\n    elements: t.Sequence[str] = (\"H\", \"He\", \"C\", \"N\", \"O\"),\n    abundances: t.Sequence[float] = (\n        12,\n        10.93,\n        8.39,\n        7.86,\n        8.73,\n    ),\n    **kwargs: t.Any,\n) -&gt; npt.NDArray[np.floating]:\n    \"\"\"Loads and runs the ACE chemistry model.\"\"\"\n    from ..ace import equil_chemistry_ace\n\n    return equil_chemistry_ace(\n        composition=species,\n        therm_file=therm_file,\n        elements=elements,\n        abundances=abundances,\n        temperature=temperature,\n        pressure=pressure,\n    )\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.default_full_network_loader","title":"<code>default_full_network_loader()</code>","text":"<p>Load the default full network.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def default_full_network_loader() -&gt; VenotChemicalNetwork:\n    \"\"\"Load the default full network.\"\"\"\n    import importlib.resources\n    import pathlib\n\n    full_network_path = importlib.resources.files(\"freckll.data\") / \"Venot2020_Taurex\"\n    full_network_path = full_network_path.resolve()\n    full_network_path = pathlib.Path(full_network_path)\n\n    return VenotChemicalNetwork(\n        full_network_path,\n    )\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.default_network_loader","title":"<code>default_network_loader(network)</code>","text":"<p>Load the default network.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Networks</code> <p>The network to load. Can be \"venot-methanol-2023\" or \"venot-methanol-2023-reduced\".</p> required <p>Returns:</p> Type Description <code>VenotChemicalNetwork</code> <p>The loaded network.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def default_network_loader(network: Networks) -&gt; VenotChemicalNetwork:\n    \"\"\"Load the default network.\n\n    Args:\n        network: The network to load. Can be \"venot-methanol-2023\" or \"venot-methanol-2023-reduced\".\n\n    Returns:\n        The loaded network.\n\n    \"\"\"\n    if network == \"venot-methanol-2023\":\n        return default_full_network_loader()\n    elif network == \"venot-methanol-2023-reduced\":\n        return default_reduced_network_loader()\n    else:\n        raise ValueError(f\"Unknown network '{network}'\")\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.default_photonetwork_loader","title":"<code>default_photonetwork_loader(species_list)</code>","text":"<p>Load the default photo network.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def default_photonetwork_loader(species_list: list[SpeciesFormula]) -&gt; VenotPhotoChemistry:\n    \"\"\"Load the default photo network.\"\"\"\n    import importlib.resources\n\n    photo_file = importlib.resources.files(\"freckll.data\") / \"Venot2020_Taurex\" / \"photodissociations.dat\"\n    photo_file = photo_file.resolve()\n    section_path = importlib.resources.files(\"freckll.data\") / \"Sections\"\n\n    section_path = section_path.resolve()\n\n    return VenotPhotoChemistry(\n        species_list,\n        photodissociation_file=photo_file,\n        cross_section_path=section_path,\n    )\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.default_reduced_network_loader","title":"<code>default_reduced_network_loader()</code>","text":"<p>Load the default reduced network.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def default_reduced_network_loader() -&gt; VenotChemicalNetwork:\n    \"\"\"Load the default reduced network.\"\"\"\n    import importlib.resources\n    import pathlib\n\n    reduced_network_path = importlib.resources.files(\"freckll.data\") / \"Venot2020_reduced_TAUREX\"\n    reduced_network_path = reduced_network_path.resolve()\n    reduced_network_path = pathlib.Path(reduced_network_path)\n\n    return VenotChemicalNetwork(\n        reduced_network_path,\n    )\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.default_stellar_spectra_loader","title":"<code>default_stellar_spectra_loader(star)</code>","text":"<p>Load the default stellar spectra.</p> <p>Parameters:</p> Name Type Description Default <code>star</code> <code>Stars</code> <p>The star to load. Can be \"55cnc\", \"adleo\", \"gj436\", \"gj3470\", \"hd128167\", \"hd189733\", \"hd209458\", \"sun\", \"wasp12\", \"wasp39\", \"wasp43\".</p> required <p>Returns:</p> Type Description <code>StarSpectra</code> <p>The loaded stellar spectra.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def default_stellar_spectra_loader(\n    star: Stars,\n) -&gt; StarSpectra:\n    \"\"\"Load the default stellar spectra.\n\n    Args:\n        star: The star to load. Can be \"55cnc\", \"adleo\", \"gj436\", \"gj3470\", \"hd128167\", \"hd189733\", \"hd209458\", \"sun\", \"wasp12\", \"wasp39\", \"wasp43\".\n\n    Returns:\n        The loaded stellar spectra.\n    \"\"\"\n\n    import importlib.resources\n    import pathlib\n\n    if star not in t.get_args(Stars):\n        raise ValueError(f\"Unknown star '{star}'\")\n\n    star_path = importlib.resources.files(\"freckll.data\") / \"Stars\" / f\"stellarflux_{star}.dat\"\n    star_path = star_path.resolve()\n    star_path = pathlib.Path(star_path)\n\n    with open(star_path) as f:\n        wav, flux = np.loadtxt(\n            f,\n            unpack=True,\n        )\n\n    return StarSpectra(\n        wav &lt;&lt; u.nm,\n        flux &lt;&lt; u.photon / u.cm**2 / u.s / u.nm,\n        reference_distance=1.0 * u.AU,\n    )\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.generic_csv_loader","title":"<code>generic_csv_loader(filename, columns, column_units, skiprows=0, delimiter=None, comments=None)</code>","text":"<p>Load a csv file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>PathLike</code> <p>Path to the csv file.</p> required <code>columns</code> <code>list[int]</code> <p>List of columns to load. 0 being first</p> required <code>column_units</code> <code>list[Unit | None]</code> <p>List of units for each column.</p> required <code>skiprows</code> <code>Optional[int]</code> <p>Number of rows to skip at the beginning of the file.</p> <code>0</code> <code>delimiter</code> <code>Optional[str]</code> <p>Delimiter used in the file.</p> <code>None</code> <code>comments</code> <code>Optional[str]</code> <p>Comment character in the file.</p> <code>None</code> <p>Returns:     Tuple of quantities for each column.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def generic_csv_loader(\n    filename: PathLike,\n    columns: list[int],\n    column_units: list[u.Unit | None],\n    skiprows: t.Optional[int] = 0,\n    delimiter: t.Optional[str] = None,\n    comments: t.Optional[str] = None,\n) -&gt; tuple[u.Quantity | npt.NDArray[np.floating], ...]:\n    \"\"\"Load a csv file\n\n    Args:\n        filename: Path to the csv file.\n        columns: List of columns to load. 0 being first\n        column_units: List of units for each column.\n        skiprows: Number of rows to skip at the beginning of the file.\n        delimiter: Delimiter used in the file.\n        comments: Comment character in the file.\n    Returns:\n        Tuple of quantities for each column.\n\n    \"\"\"\n    filename = pathlib.Path(filename)\n    if not filename.exists():\n        raise FileNotFoundError(f\"File {filename} does not exist.\")\n\n    if not filename.is_file():\n        raise FileNotFoundError(f\"File {filename} is not a file.\")\n\n    columns = [int(c) for c in columns]\n\n    with open(filename) as f:\n        res = np.loadtxt(\n            f,\n            skiprows=int(skiprows),\n            delimiter=delimiter,\n            usecols=columns,\n            comments=comments,\n            unpack=True,\n        )\n\n    # Convert to quantities\n    quantities = []\n    for data, quantity in zip(res, column_units):\n        if quantity is None:\n            quantities.append(data)\n        else:\n            quantities.append(data * quantity)\n    return tuple(quantities)\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.kzz_profile_loader","title":"<code>kzz_profile_loader(*, filename, kzz_column, pressure_column, kzz_unit, pressure_unit, skiprows=0, delimiter=None, comments=None, start='bottom')</code>","text":"<p>Load a kzz profile from a csv file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>PathLike</code> <p>Path to the csv file.</p> required <code>kzz_column</code> <code>int</code> <p>Column index for kzz. 0 being first</p> required <code>pressure_column</code> <code>int</code> <p>Column index for pressure. 0 being first</p> required <code>kzz_unit</code> <code>Unit</code> <p>Unit for kzz.</p> required <code>skiprows</code> <code>Optional[int]</code> <p>Number of rows to skip at the beginning of the file.</p> <code>0</code> <code>delimiter</code> <code>Optional[str]</code> <p>Delimiter used in the file.</p> <code>None</code> <code>comments</code> <code>Optional[str]</code> <p>Comment character in the file.</p> <code>None</code> <p>Returns:     Tuple of kzz and pressure quantities.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def kzz_profile_loader(\n    *,\n    filename: PathLike,\n    kzz_column: int,\n    pressure_column: int,\n    kzz_unit: u.Unit,\n    pressure_unit: u.Unit,\n    skiprows: t.Optional[int] = 0,\n    delimiter: t.Optional[str] = None,\n    comments: t.Optional[str] = None,\n    start: t.Literal[\"top\", \"bottom\"] = \"bottom\",\n) -&gt; tuple[u.Quantity, u.Quantity]:\n    \"\"\"Load a kzz profile from a csv file.\n\n    Args:\n        filename: Path to the csv file.\n        kzz_column: Column index for kzz. 0 being first\n        pressure_column: Column index for pressure. 0 being first\n        kzz_unit: Unit for kzz.\n        skiprows: Number of rows to skip at the beginning of the file.\n        delimiter: Delimiter used in the file.\n        comments: Comment character in the file.\n    Returns:\n        Tuple of kzz and pressure quantities.\n\n\n    \"\"\"\n    pressure, kzz = generic_csv_loader(\n        filename,\n        [pressure_column, kzz_column],\n        [pressure_unit, kzz_unit],\n        skiprows=skiprows,\n        delimiter=delimiter,\n        comments=comments,\n    )\n\n    # Reverse the profile if it starts at the top\n    if start == \"top\":\n        pressure = pressure[::-1]\n        kzz = kzz[::-1]\n    return pressure, kzz\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.star_spectra_loader","title":"<code>star_spectra_loader(*, filename, flux_column, spectral_column, flux_unit, spectral_unit, reference_distance, skiprows=0, delimiter=None, comments=None)</code>","text":"<p>Load a kzz profile from a csv file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>PathLike</code> <p>Path to the csv file.</p> required <code>flux_column</code> <code>int</code> <p>Column index for flux. 0 being first</p> required <code>spectral_column</code> <code>int</code> <p>Column index for spectral. 0 being first</p> required <code>flux_unit</code> <code>Unit</code> <p>Unit for flux.</p> required <code>spectral_unit</code> <code>Unit</code> <p>Unit for spectral.</p> required <code>reference_distance</code> <code>Quantity</code> <p>Reference distance for the flux.</p> required <code>skiprows</code> <code>Optional[int]</code> <p>Number of rows to skip at the beginning of the file.</p> <code>0</code> <code>delimiter</code> <code>Optional[str]</code> <p>Delimiter used in the file.</p> <code>None</code> <code>comments</code> <code>Optional[str]</code> <p>Comment character in the file.</p> <code>None</code> <p>Returns:     Tuple of kzz and pressure quantities.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def star_spectra_loader(\n    *,\n    filename: PathLike,\n    flux_column: int,\n    spectral_column: int,\n    flux_unit: u.Unit,\n    spectral_unit: u.Unit,\n    reference_distance: u.Quantity,\n    skiprows: t.Optional[int] = 0,\n    delimiter: t.Optional[str] = None,\n    comments: t.Optional[str] = None,\n) -&gt; StarSpectra:\n    \"\"\"Load a kzz profile from a csv file.\n\n    Args:\n        filename: Path to the csv file.\n        flux_column: Column index for flux. 0 being first\n        spectral_column: Column index for spectral. 0 being first\n        flux_unit: Unit for flux.\n        spectral_unit: Unit for spectral.\n        reference_distance: Reference distance for the flux.\n        skiprows: Number of rows to skip at the beginning of the file.\n        delimiter: Delimiter used in the file.\n        comments: Comment character in the file.\n    Returns:\n        Tuple of kzz and pressure quantities.\n\n\n    \"\"\"\n    wav, flux = generic_csv_loader(\n        filename,\n        [spectral_column, flux_column],\n        [spectral_unit, flux_unit],\n        skiprows=skiprows,\n        delimiter=delimiter,\n        comments=comments,\n    )\n\n    return StarSpectra(\n        wav,\n        flux,\n        reference_distance=reference_distance,\n    )\n</code></pre>"},{"location":"modules/io/loader/#freckll.io.loader.tp_profile_loader","title":"<code>tp_profile_loader(*, filename, temperature_column, pressure_column, temperature_unit, pressure_unit, skiprows=0, delimiter=None, comments=None, start='bottom')</code>","text":"<p>Load a temperature-pressure profile from a csv file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>PathLike</code> <p>Path to the csv file.</p> required <code>temperature_column</code> <code>int</code> <p>Column index for temperature. 0 being first</p> required <code>pressure_column</code> <code>int</code> <p>Column index for pressure. 0 being first</p> required <code>temperature_unit</code> <code>Unit</code> <p>Unit for temperature.</p> required <code>skiprows</code> <code>Optional[int]</code> <p>Number of rows to skip at the beginning of the file.</p> <code>0</code> <code>delimiter</code> <code>Optional[str]</code> <p>Delimiter used in the file.</p> <code>None</code> <code>comments</code> <code>Optional[str]</code> <p>Comment character in the file.</p> <code>None</code> <code>start</code> <code>Literal['top', 'bottom']</code> <p>Whether the profile starts at the top or bottom of the atmosphere.</p> <code>'bottom'</code> <p>Returns:     Tuple of temperature and pressure quantities.</p> Source code in <code>src/freckll/io/loader.py</code> <pre><code>def tp_profile_loader(\n    *,\n    filename: PathLike,\n    temperature_column: int,\n    pressure_column: int,\n    temperature_unit: u.Unit,\n    pressure_unit: u.Unit,\n    skiprows: t.Optional[int] = 0,\n    delimiter: t.Optional[str] = None,\n    comments: t.Optional[str] = None,\n    start: t.Literal[\"top\", \"bottom\"] = \"bottom\",\n) -&gt; tuple[u.Quantity, u.Quantity]:\n    \"\"\"Load a temperature-pressure profile from a csv file.\n\n    Args:\n        filename: Path to the csv file.\n        temperature_column: Column index for temperature. 0 being first\n        pressure_column: Column index for pressure. 0 being first\n        temperature_unit: Unit for temperature.\n        skiprows: Number of rows to skip at the beginning of the file.\n        delimiter: Delimiter used in the file.\n        comments: Comment character in the file.\n        start: Whether the profile starts at the top or bottom of the atmosphere.\n    Returns:\n        Tuple of temperature and pressure quantities.\n    \"\"\"\n    pressure, temperature = generic_csv_loader(\n        filename,\n        [pressure_column, temperature_column],\n        [pressure_unit, temperature_unit],\n        skiprows=skiprows,\n        delimiter=delimiter,\n        comments=comments,\n    )\n\n    # Reverse the profile if it starts at the top\n    if start == \"top\":\n        pressure = pressure[::-1]\n        temperature = temperature[::-1]\n\n    return pressure, temperature\n</code></pre>"},{"location":"modules/reactions/common/","title":"Common","text":"<p>Common functions and equations for reactions.</p>"},{"location":"modules/reactions/common/#freckll.reactions.common.collision_rate_array","title":"<code>collision_rate_array(reduced_masses, num_species, k_rate, k_inf, m_concentration, temperature)</code>","text":"<p>Limits the reaction rate to the collision rate.</p> <p>Parameters:</p> Name Type Description Default <code>reduced_masses</code> <code>FreckllArray</code> <p>The reduced masses of the reactants.</p> required <code>num_species</code> <code>FreckllArrayInt</code> <p>The number of species in the reaction.</p> required <code>k_rate</code> <code>FreckllArray</code> <p>The rate constant of the reaction.</p> required <code>k_inf</code> <code>FreckllArray</code> <p>high-pressure limit of the rate constant.</p> required <code>m_concentration</code> <code>FreckllArray</code> <p>The concentration of the reactants.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the reaction.</p> required Source code in <code>src/freckll/reactions/common.py</code> <pre><code>def collision_rate_array(\n    reduced_masses: FreckllArray,\n    num_species: FreckllArrayInt,\n    k_rate: FreckllArray,\n    k_inf: FreckllArray,\n    m_concentration: FreckllArray,\n    temperature: FreckllArray,\n) -&gt; FreckllArray:\n    \"\"\"Limits the reaction rate to the collision rate.\n\n    Args:\n        reduced_masses: The reduced masses of the reactants.\n        num_species: The number of species in the reaction.\n        k_rate: The rate constant of the reaction.\n        k_inf: high-pressure limit of the rate constant.\n        m_concentration: The concentration of the reactants.\n        temperature: The temperature of the reaction.\n\n\n    \"\"\"\n    eff_xsec = 4.0 * np.pi * (RA * RA)\n\n    avg_speed = np.sqrt((8 * K_BOLTZMANN * temperature[None, :]) / (np.pi * reduced_masses[:, None]))\n\n    k_coll = eff_xsec * avg_speed\n\n    update_mask = k_rate &gt;= k_coll\n\n    uni_reactions = num_species[:, None] == 1\n    if np.any(uni_reactions):\n        k_kinf = np.divide(k_rate * m_concentration, k_inf, where=k_inf != 0)\n        k_rate_coll = k_rate / k_coll\n        kinf_zero = k_inf == 0\n        k_rate_exceeds_kinf = k_kinf &gt; 1.0\n        k_rate_condition = k_rate_coll &gt; k_kinf\n        k_rate = np.where(\n            update_mask &amp; uni_reactions &amp; (kinf_zero | k_rate_exceeds_kinf) &amp; (~kinf_zero) &amp; k_rate_condition,\n            k_coll,\n            k_rate,\n        )\n\n    k_rate = np.where(update_mask &amp; ~uni_reactions, k_coll, k_rate)\n\n    return k_rate\n</code></pre>"},{"location":"modules/reactions/common/#freckll.reactions.common.collision_rate_limit","title":"<code>collision_rate_limit(reactants, k_rate, k_inf, m_concentration, temperature)</code>","text":"<p>Limits the reaction rate to the collision rate.</p> <p>Parameters:</p> Name Type Description Default <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants in the reaction.</p> required <code>k_rate</code> <code>FreckllArray</code> <p>The rate constant of the reaction.</p> required <code>k_inf</code> <code>FreckllArray</code> <p>high-pressure limit of the rate constant.</p> required <code>m_concentration</code> <code>FreckllArray</code> <p>The concentration of the reactants.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the reaction.</p> required Source code in <code>src/freckll/reactions/common.py</code> <pre><code>def collision_rate_limit(\n    reactants: list[SpeciesFormula],\n    k_rate: FreckllArray,\n    k_inf: FreckllArray,\n    m_concentration: FreckllArray,\n    temperature: FreckllArray,\n) -&gt; FreckllArray:\n    \"\"\"Limits the reaction rate to the collision rate.\n\n    Args:\n        reactants: The reactants in the reaction.\n        k_rate: The rate constant of the reaction.\n        k_inf: high-pressure limit of the rate constant.\n        m_concentration: The concentration of the reactants.\n        temperature: The temperature of the reaction.\n\n\n    \"\"\"\n    uni_reaction = len(reactants) == 1\n    kboltz = K_BOLTZMANN * 1e4\n    spec1 = reactants[0]\n    try:\n        spec2 = reactants[1]\n    except IndexError:\n        spec2 = H2\n\n    #\n    mass1 = spec1.monoisotopic_mass / AVO * 1e-3\n    mass2 = spec2.monoisotopic_mass / AVO * 1e-3\n\n    reduced_mass = (mass1 + mass2) / 2\n\n    eff_xsec = 4.0 * np.pi * (RA * RA)\n\n    avg_speed = np.sqrt((8 * kboltz * temperature) / (np.pi * reduced_mass))\n\n    k_coll = eff_xsec * avg_speed\n\n    update_mask = k_rate &gt;= k_coll\n\n    if uni_reaction:\n        k_kinf = np.divide(k_rate * m_concentration, k_inf, where=k_inf != 0)\n        k_rate_coll = k_rate / k_coll\n        kinf_zero = k_inf == 0\n        k_rate_exceeds_kinf = k_kinf &gt; 1.0\n        k_rate_condition = k_rate_coll &gt; k_kinf\n        k_rate = np.where(\n            update_mask &amp; (kinf_zero | k_rate_exceeds_kinf) &amp; (~kinf_zero) &amp; k_rate_condition,\n            k_coll,\n            k_rate,\n        )\n    else:\n        k_rate = np.where(update_mask, k_coll, k_rate)\n\n    return k_rate\n</code></pre>"},{"location":"modules/reactions/common/#freckll.reactions.common.compile_thermodynamic_properties","title":"<code>compile_thermodynamic_properties(species, nasa_coeffs, temperature)</code>","text":"<p>Compiles the thermodynamic properties of the species in the reaction.</p> <p>Resultant array will be of shape (Nspecies,2, Nlayers)</p> <p>Where the second axis is the enthalpy and entropy.</p> <p>Parameters:</p> Name Type Description Default <code>species</code> <code>list[SpeciesFormula]</code> <p>The species in the network.</p> required <code>nasa_coeffs</code> <code>SpeciesDict[NasaCoeffs]</code> <p>The NASA polynomial coefficients of the species.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the reaction.</p> required <p>Returns:</p> Type Description <code>FreckllArray</code> <p>The thermodynamic properties of the species.</p> Source code in <code>src/freckll/reactions/common.py</code> <pre><code>def compile_thermodynamic_properties(\n    species: list[SpeciesFormula],\n    nasa_coeffs: SpeciesDict[NasaCoeffs],\n    temperature: FreckllArray,\n) -&gt; FreckllArray:\n    \"\"\"Compiles the thermodynamic properties of the species in the reaction.\n\n    Resultant array will be of shape (Nspecies,2, Nlayers)\n\n    Where the second axis is the enthalpy and entropy.\n\n    Args:\n        species: The species in the network.\n        nasa_coeffs: The NASA polynomial coefficients of the species.\n        temperature: The temperature of the reaction.\n\n    Returns:\n        The thermodynamic properties of the species.\n    \"\"\"\n    thermo_properties = np.empty(shape=(len(species), 2, temperature.shape[0]), dtype=temperature.dtype)\n\n    for idx, spec in enumerate(species):\n        if spec.state != \"gas\":\n            continue\n        nasa = nasa_coeffs[spec]\n        h, s = nasa(temperature)\n        thermo_properties[idx, 0] = h\n        thermo_properties[idx, 1] = s\n\n    return thermo_properties\n</code></pre>"},{"location":"modules/reactions/common/#freckll.reactions.common.invert_reaction","title":"<code>invert_reaction(thermo_inv_reactants, thermo_inv_products, k0, k_inf, temperature)</code>","text":"<p>Reverses the reaction.</p> <p>Parameters:</p> Name Type Description Default <code>thermo_inv_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_inv_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <code>k0</code> <code>FreckllArray</code> <p>The rate constant of the reaction.</p> required <code>k_inf</code> <code>FreckllArray</code> <p>The high-pressure limit of the rate constant.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the reaction.</p> required <p>Returns:</p> Type Description <code>tuple[FreckllArray, FreckllArray, FreckllArray]</code> <p>The inverted rate constants \\(k_0\\), \\(k_\\infty\\) and the equilibrium constant \\(K\\).</p> Source code in <code>src/freckll/reactions/common.py</code> <pre><code>def invert_reaction(\n    thermo_inv_reactants: FreckllArray,\n    thermo_inv_products: FreckllArray,\n    k0: FreckllArray,\n    k_inf: FreckllArray,\n    temperature: FreckllArray,\n) -&gt; tuple[FreckllArray, FreckllArray, FreckllArray]:\n    r\"\"\"Reverses the reaction.\n\n    Args:\n        thermo_inv_reactants: The thermodynamic properties of the reactants.\n        thermo_inv_products: The thermodynamic properties of the products.\n        k0: The rate constant of the reaction.\n        k_inf: The high-pressure limit of the rate constant.\n        temperature: The temperature of the reaction.\n\n    Returns:\n        The inverted rate constants $k_0$, $k_\\infty$ and the equilibrium constant $K$.\n\n\n    \"\"\"\n    from ..constants import ATM_BAR, AVO\n\n    r_si = 8.3144598\n\n    sum_reactants = np.sum(thermo_inv_reactants, axis=0)\n    sum_products = np.sum(thermo_inv_products, axis=0)\n\n    delta_h = sum_reactants[0] - sum_products[0]\n    delta_s = sum_reactants[1] - sum_products[1]\n    exp_dh = np.exp(delta_s - delta_h)\n\n    d_stoic = thermo_inv_reactants.shape[0] - thermo_inv_products.shape[0]\n\n    k_factor = (ATM_BAR * AVO) / (r_si * temperature * 10)\n\n    k_equil = exp_dh * k_factor**d_stoic\n\n    k0_inv = k0 / k_equil\n\n    k_inf_inv = k_inf / k_equil\n\n    return k0_inv, k_inf_inv, k_equil\n</code></pre>"},{"location":"modules/reactions/data/","title":"Data","text":"<p>Handles storing reactions.</p>"},{"location":"modules/reactions/data/#freckll.reactions.data.Reaction","title":"<code>Reaction</code>  <code>dataclass</code>","text":"Source code in <code>src/freckll/reactions/data.py</code> <pre><code>@dataclass\nclass Reaction:\n    reactants: list[SpeciesFormula]\n    products: list[SpeciesFormula]\n    reactants_indices: FreckllArrayInt\n    product_indices: FreckllArrayInt\n    reaction_rate: FreckllArray\n    tags: list[str]\n    dens_krate: FreckllArray = None\n\n    def calculate_density_krate(self, number_density: FreckllArray):\n        \"\"\"Calculate the density krate.\"\"\"\n        reactants_dens = np.prod(number_density[self.reactants_indices], axis=0)\n        self.dens_krate = self.reaction_rate * reactants_dens\n\n    def __repr__(self):\n        reactants = \" + \".join([str(x) for x in self.reactants])\n        products = \" + \".join([str(x) for x in self.products])\n        return f\"{reactants} -&gt; {products} ({self.reaction_rate.mean():.2e}) ({self.tags})\"\n</code></pre>"},{"location":"modules/reactions/data/#freckll.reactions.data.Reaction.calculate_density_krate","title":"<code>calculate_density_krate(number_density)</code>","text":"<p>Calculate the density krate.</p> Source code in <code>src/freckll/reactions/data.py</code> <pre><code>def calculate_density_krate(self, number_density: FreckllArray):\n    \"\"\"Calculate the density krate.\"\"\"\n    reactants_dens = np.prod(number_density[self.reactants_indices], axis=0)\n    self.dens_krate = self.reaction_rate * reactants_dens\n</code></pre>"},{"location":"modules/reactions/data/#freckll.reactions.data.ReactionCall","title":"<code>ReactionCall</code>","text":"<p>A function that builds a standardized reaction computation.</p> Source code in <code>src/freckll/reactions/data.py</code> <pre><code>class ReactionCall:\n    \"\"\"A function that builds a standardized reaction computation.\"\"\"\n\n    def __init__(\n        self,\n        species_list: list[SpeciesFormula],\n        reactants: list[SpeciesFormula],\n        products: list[SpeciesFormula],\n        tags: list[str],\n        inverted: bool,\n        reaction_function: t.Callable[..., ReactionFunction],\n    ) -&gt; None:\n        \"\"\"Initialize the reaction call.\n\n        Args:\n            species_list: The species list.\n            reactants: The reactants.\n            products: The products.\n            tags: The tags.\n            inverted: Whether the reaction is inverted.\n            reaction_function: The reaction function.\n\n\n\n        \"\"\"\n        self.reactants = reactants\n        self.products = products\n        self.inverted = inverted\n        self.reaction_function = reaction_function\n        self.tags = tags\n        self.reactants_indices = np.array([species_list.index(x) for x in reactants])\n        self.product_indices = [species_list.index(x) for x in products]\n\n    def compile(\n        self,\n        temperature: FreckllArray,\n        pressure: FreckllArray,\n        thermo_properties: FreckllArray,\n    ) -&gt; None:\n        \"\"\"Compile the reaction.\"\"\"\n        thermo_reactants = thermo_properties[self.reactants_indices]\n        thermo_products = thermo_properties[self.product_indices]\n\n        self.reaction_call = self.reaction_function(temperature, pressure, thermo_reactants, thermo_products)\n\n    def __call__(\n        self,\n        concentration: FreckllArray,\n    ) -&gt; list[Reaction]:\n        \"\"\"Call the reaction.\n\n        A normalised reaction call.\n\n        Args:\n            concentration: The concentration.\n\n        Returns:\n            list[Reaction]: The reaction.\n\n\n        \"\"\"\n        reaction_rate = self.reaction_call(concentration)\n        reactions = [\n            Reaction(\n                self.reactants,\n                self.products,\n                self.reactants_indices,\n                self.product_indices,\n                reaction_rate[0],\n                self.tags,\n            )\n        ]\n        if self.inverted:\n            reactions.append(\n                Reaction(\n                    self.products,\n                    self.reactants,\n                    self.product_indices,\n                    self.reactants_indices,\n                    reaction_rate[1],\n                    [*self.tags, \"inverted\"],\n                )\n            )\n        for r in reactions:\n            r.calculate_density_krate(concentration)\n        return reactions\n\n    def __repr__(self) -&gt; str:\n        return f\"ReactionCall({self.reactants}{'-&gt;' if not self.inverted else '&lt;-&gt;'}{self.products}, {self.tags})\"\n</code></pre>"},{"location":"modules/reactions/data/#freckll.reactions.data.ReactionCall.__call__","title":"<code>__call__(concentration)</code>","text":"<p>Call the reaction.</p> <p>A normalised reaction call.</p> <p>Parameters:</p> Name Type Description Default <code>concentration</code> <code>FreckllArray</code> <p>The concentration.</p> required <p>Returns:</p> Type Description <code>list[Reaction]</code> <p>list[Reaction]: The reaction.</p> Source code in <code>src/freckll/reactions/data.py</code> <pre><code>def __call__(\n    self,\n    concentration: FreckllArray,\n) -&gt; list[Reaction]:\n    \"\"\"Call the reaction.\n\n    A normalised reaction call.\n\n    Args:\n        concentration: The concentration.\n\n    Returns:\n        list[Reaction]: The reaction.\n\n\n    \"\"\"\n    reaction_rate = self.reaction_call(concentration)\n    reactions = [\n        Reaction(\n            self.reactants,\n            self.products,\n            self.reactants_indices,\n            self.product_indices,\n            reaction_rate[0],\n            self.tags,\n        )\n    ]\n    if self.inverted:\n        reactions.append(\n            Reaction(\n                self.products,\n                self.reactants,\n                self.product_indices,\n                self.reactants_indices,\n                reaction_rate[1],\n                [*self.tags, \"inverted\"],\n            )\n        )\n    for r in reactions:\n        r.calculate_density_krate(concentration)\n    return reactions\n</code></pre>"},{"location":"modules/reactions/data/#freckll.reactions.data.ReactionCall.__init__","title":"<code>__init__(species_list, reactants, products, tags, inverted, reaction_function)</code>","text":"<p>Initialize the reaction call.</p> <p>Parameters:</p> Name Type Description Default <code>species_list</code> <code>list[SpeciesFormula]</code> <p>The species list.</p> required <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products.</p> required <code>tags</code> <code>list[str]</code> <p>The tags.</p> required <code>inverted</code> <code>bool</code> <p>Whether the reaction is inverted.</p> required <code>reaction_function</code> <code>Callable[..., ReactionFunction]</code> <p>The reaction function.</p> required Source code in <code>src/freckll/reactions/data.py</code> <pre><code>def __init__(\n    self,\n    species_list: list[SpeciesFormula],\n    reactants: list[SpeciesFormula],\n    products: list[SpeciesFormula],\n    tags: list[str],\n    inverted: bool,\n    reaction_function: t.Callable[..., ReactionFunction],\n) -&gt; None:\n    \"\"\"Initialize the reaction call.\n\n    Args:\n        species_list: The species list.\n        reactants: The reactants.\n        products: The products.\n        tags: The tags.\n        inverted: Whether the reaction is inverted.\n        reaction_function: The reaction function.\n\n\n\n    \"\"\"\n    self.reactants = reactants\n    self.products = products\n    self.inverted = inverted\n    self.reaction_function = reaction_function\n    self.tags = tags\n    self.reactants_indices = np.array([species_list.index(x) for x in reactants])\n    self.product_indices = [species_list.index(x) for x in products]\n</code></pre>"},{"location":"modules/reactions/data/#freckll.reactions.data.ReactionCall.compile","title":"<code>compile(temperature, pressure, thermo_properties)</code>","text":"<p>Compile the reaction.</p> Source code in <code>src/freckll/reactions/data.py</code> <pre><code>def compile(\n    self,\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_properties: FreckllArray,\n) -&gt; None:\n    \"\"\"Compile the reaction.\"\"\"\n    thermo_reactants = thermo_properties[self.reactants_indices]\n    thermo_products = thermo_properties[self.product_indices]\n\n    self.reaction_call = self.reaction_function(temperature, pressure, thermo_reactants, thermo_products)\n</code></pre>"},{"location":"modules/reactions/falloff/","title":"Falloff","text":"<p>Falloff functions for reactions.</p>"},{"location":"modules/reactions/falloff/#freckll.reactions.falloff.FalloffFunction","title":"<code>FalloffFunction</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines a calloff function protocol.</p> Source code in <code>src/freckll/reactions/falloff.py</code> <pre><code>class FalloffFunction(t.Protocol):\n    \"\"\"Defines a calloff function protocol.\"\"\"\n\n    def __call__(\n        self,\n        k0: FreckllArray,\n        kinf: FreckllArray,\n        m: FreckllArray,\n        temperature: FreckllArray,\n        *args: float,\n    ) -&gt; FreckllArray: ...\n</code></pre>"},{"location":"modules/reactions/falloff/#freckll.reactions.falloff.no_falloff","title":"<code>no_falloff(k0, kinf, m, temperature, *args)</code>","text":"<p>No falloff function.</p> Source code in <code>src/freckll/reactions/falloff.py</code> <pre><code>def no_falloff(\n    k0: FreckllArray,\n    kinf: FreckllArray,\n    m: FreckllArray,\n    temperature: FreckllArray,\n    *args: float,\n) -&gt; FreckllArray:\n    \"\"\"No falloff function.\"\"\"\n    return 1.0\n</code></pre>"},{"location":"modules/reactions/falloff/#freckll.reactions.falloff.sri_falloff","title":"<code>sri_falloff(k0, kinf, m, temperature, a_sri, b_sri, c_sri, d_sri, e_sri)</code>","text":"<p>Stanford Research Institute falloff function.</p> <p>Computes the Stan falloff function, first \\(X_{sri}\\) is computed as:</p> \\[ X_{SRI} = \\frac{1}{1 + [\\log_{10}(\\frac{k_0 M}{k_\\infty})]^2} \\] <p>The center fall-off factor is: $$ F_{c} = d_{SRI}(a_{SRI} \\exp(-\\frac{b_{SRI}}{T}) + \\exp(-\\frac{T}{c_{SRI}}))^{X_{SRI}}\\times T^{e_{SRI}} $$</p> <p>Parameters:</p> Name Type Description Default <code>k0</code> <code>FreckllArray</code> <p>The low-pressure rate constant.</p> required <code>kinf</code> <code>FreckllArray</code> <p>The high-pressure rate constant.</p> required <code>m</code> <code>FreckllArray</code> <p>The concentration of the reactants.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the reaction.</p> required <code>a_sri</code> <code>float</code> <p>The SRI falloff parameter.</p> required <code>b_sri</code> <code>float</code> <p>The SRI falloff parameter.</p> required <code>c_sri</code> <code>float</code> <p>The SRI falloff parameter.</p> required <code>d_sri</code> <code>float</code> <p>The SRI falloff parameter.</p> required <code>e_sri</code> <code>float</code> <p>The SRI falloff parameter.</p> required Source code in <code>src/freckll/reactions/falloff.py</code> <pre><code>def sri_falloff(\n    k0: FreckllArray,\n    kinf: FreckllArray,\n    m: FreckllArray,\n    temperature: FreckllArray,\n    a_sri: float,\n    b_sri: float,\n    c_sri: float,\n    d_sri: float,\n    e_sri: float,\n) -&gt; FreckllArray:\n    r\"\"\"Stanford Research Institute falloff function.\n\n    Computes the Stan falloff function, first $X_{sri}$ is computed as:\n\n    $$\n    X_{SRI} = \\frac{1}{1 + [\\log_{10}(\\frac{k_0 M}{k_\\infty})]^2}\n    $$\n\n    The center fall-off factor is:\n    $$\n    F_{c} = d_{SRI}(a_{SRI} \\exp(-\\frac{b_{SRI}}{T}) + \\exp(-\\frac{T}{c_{SRI}}))^{X_{SRI}}\\times T^{e_{SRI}}\n    $$\n\n    Args:\n        k0: The low-pressure rate constant.\n        kinf: The high-pressure rate constant.\n        m: The concentration of the reactants.\n        temperature: The temperature of the reaction.\n        a_sri: The SRI falloff parameter.\n        b_sri: The SRI falloff parameter.\n        c_sri: The SRI falloff parameter.\n        d_sri: The SRI falloff parameter.\n        e_sri: The SRI falloff parameter.\n    \"\"\"\n\n    x_sri = 1 / (1 + np.log10(k0 * m / kinf) ** 2)\n\n    f_cent = (\n        d_sri * (a_sri * np.exp(-b_sri / temperature) + np.exp(-temperature / c_sri))\n    ) ** x_sri * temperature**e_sri\n\n    return t.cast(FreckllArray, f_cent)\n</code></pre>"},{"location":"modules/reactions/falloff/#freckll.reactions.falloff.troe_falloff_term","title":"<code>troe_falloff_term(k0, kinf, m, temperature, a_troe, t3, t1, t2)</code>","text":"<p>Troe Falloff function.</p> <p>Computes the center factor: $$ F_{c} = (1-\\alpha)\\exp{\\frac{-T}{T_3}} + \\alpha\\exp{\\frac{-T}{T_1}} + \\exp{\\frac{-T_2}{T}} $$ The constants: $$ c = -0.4 - 0.67\\log_{10}(F_c) $$ $$ N = 0.75 - 1.27\\log_{10}(F_c) $$</p> <p>The logarithmic falloff factor is: $$ \\log_{10}(F) = \\frac{\\log_{10}(F_c)}{1 + (\\log_{10}(\\frac{k_0}{k_\\infty}) + \\frac{c}{N - d\\log_{10}(\\frac{k_0}{k_\\infty}) + c})^2} $$</p> <p>Finally we return the factor as: $$ F = 10^{\\log_{10}(F)} $$</p> <p>Parameters:</p> Name Type Description Default <code>k0</code> <code>FreckllArray</code> <p>The low-pressure rate constant.</p> required <code>kinf</code> <code>FreckllArray</code> <p>The high-pressure rate constant.</p> required <code>m</code> <code>FreckllArray</code> <p>The concentration of the reactants.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the reaction.</p> required <code>a_troe</code> <code>float</code> <p>The Troe falloff parameter.</p> required <code>t3</code> <code>float</code> <p>The third Troe falloff parameter.</p> required <code>t1</code> <code>float</code> <p>The first Troe falloff parameter.</p> required <code>t2</code> <code>float</code> <p>The second Troe falloff parameter.</p> required <p>Returns:</p> Name Type Description <code>falloff</code> <code>FreckllArray</code> <p>The falloff term.</p> Source code in <code>src/freckll/reactions/falloff.py</code> <pre><code>def troe_falloff_term(\n    k0: FreckllArray,\n    kinf: FreckllArray,\n    m: FreckllArray,\n    temperature: FreckllArray,\n    a_troe: float,\n    t3: float,\n    t1: float,\n    t2: float,\n) -&gt; FreckllArray:\n    r\"\"\"Troe Falloff function.\n\n    Computes the center factor:\n    $$\n    F_{c} = (1-\\alpha)\\exp{\\frac{-T}{T_3}} + \\alpha\\exp{\\frac{-T}{T_1}} + \\exp{\\frac{-T_2}{T}}\n    $$\n    The constants:\n    $$\n    c = -0.4 - 0.67\\log_{10}(F_c)\n    $$\n    $$\n    N = 0.75 - 1.27\\log_{10}(F_c)\n    $$\n\n    The logarithmic falloff factor is:\n    $$\n    \\log_{10}(F) = \\frac{\\log_{10}(F_c)}{1 + (\\log_{10}(\\frac{k_0}{k_\\infty}) + \\frac{c}{N - d\\log_{10}(\\frac{k_0}{k_\\infty}) + c})^2}\n    $$\n\n    Finally we return the factor as:\n    $$\n    F = 10^{\\log_{10}(F)}\n    $$\n\n\n    Args:\n        k0: The low-pressure rate constant.\n        kinf: The high-pressure rate constant.\n        m: The concentration of the reactants.\n        temperature: The temperature of the reaction.\n        a_troe: The Troe falloff parameter.\n        t3: The third Troe falloff parameter.\n        t1: The first Troe falloff parameter.\n        t2: The second Troe falloff parameter.\n\n    Returns:\n        falloff: The falloff term.\n\n\n    \"\"\"\n    # Falloff terms\n    d = 0.14\n    if t3 == 0.0 or t1 == 0.0:\n        return 1.0\n\n    f_cent = (1 - a_troe) * np.exp(-temperature / t3) + a_troe * np.exp(-temperature / t1) + np.exp(-t2 / temperature)\n    log_fcent = np.log10(f_cent)\n\n    c = -0.4 - 0.67 * log_fcent\n    nf = 0.75 - 1.27 * log_fcent\n    log_k0kinfm = np.log10(k0 * m / kinf)\n    log_falloff = log_fcent / (1 + ((log_k0kinfm + c) / (nf - d * (log_k0kinfm + c))) ** 2)\n\n    return t.cast(FreckllArray, 10.0**log_falloff)\n</code></pre>"},{"location":"modules/reactions/photolysis/","title":"Photochemistry","text":"<p>Module related to loading in photodisocciation data.</p>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.CrossSection","title":"<code>CrossSection</code>","text":"<p>Loads cross-section data for molecule.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>class CrossSection:\n    \"\"\"Loads cross-section data for molecule.\"\"\"\n\n    def __init__(self, molecule: SpeciesFormula, wavelength: u.Quantity, cross_section: u.Quantity) -&gt; None:\n        \"\"\"Initialize and load the cross-section data.\n\n        Args:\n            molecule: The molecule for which the cross-section is loaded.\n            wavelength: The wavelength at which the cross-section is measured.\n            cross_section: The cross-section value at the given wavelength.\n\n        \"\"\"\n        self.wavelength = wavelength\n        self.cross_section = cross_section\n        self.molecule = molecule\n\n    def interp_to(self, wavelength: u.Quantity, temperature: u.Quantity, pressure: u.Quantity) -&gt; \"CrossSection\":\n        \"\"\"Interpolate the cross section to the given wavelength, temperature and pressure\n\n        Args:\n            wavelength: The wavelength to which the cross section is interpolated.\n            temperature: The temperature at which the cross section is measured.\n            pressure: The pressure at which the cross section is measured.\n\n        Returns:\n            CrossSection: A new CrossSection object with the interpolated values.\n\n\n        \"\"\"\n\n        new_wavelength = self.wavelength.to(wavelength.unit, equivalencies=u.spectral())\n\n        return CrossSection(\n            self.molecule,\n            wavelength,\n            np.interp(wavelength.value, new_wavelength.value, self.cross_section.value, left=0.0, right=0.0)\n            &lt;&lt; self.cross_section.unit,\n        )\n\n    def __add__(self, other: \"CrossSection\") -&gt; \"CrossSection\":\n        \"\"\"Add two cross sections together.\n\n        Args:\n            other: The other cross section to add.\n\n        Returns:\n            CrossSection: A new CrossSection object with the summed values.\n\n        \"\"\"\n        if not isinstance(other, CrossSection):\n            raise TypeError(\"Can only add CrossSection objects\")\n\n        if self.molecule != other.molecule:\n            raise ValueError(\"Cannot add cross sections of different molecules\")\n\n        return CrossSection(self.molecule, self.wavelength, self.cross_section + other.cross_section)\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.CrossSection.__add__","title":"<code>__add__(other)</code>","text":"<p>Add two cross sections together.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>CrossSection</code> <p>The other cross section to add.</p> required <p>Returns:</p> Name Type Description <code>CrossSection</code> <code>CrossSection</code> <p>A new CrossSection object with the summed values.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def __add__(self, other: \"CrossSection\") -&gt; \"CrossSection\":\n    \"\"\"Add two cross sections together.\n\n    Args:\n        other: The other cross section to add.\n\n    Returns:\n        CrossSection: A new CrossSection object with the summed values.\n\n    \"\"\"\n    if not isinstance(other, CrossSection):\n        raise TypeError(\"Can only add CrossSection objects\")\n\n    if self.molecule != other.molecule:\n        raise ValueError(\"Cannot add cross sections of different molecules\")\n\n    return CrossSection(self.molecule, self.wavelength, self.cross_section + other.cross_section)\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.CrossSection.__init__","title":"<code>__init__(molecule, wavelength, cross_section)</code>","text":"<p>Initialize and load the cross-section data.</p> <p>Parameters:</p> Name Type Description Default <code>molecule</code> <code>SpeciesFormula</code> <p>The molecule for which the cross-section is loaded.</p> required <code>wavelength</code> <code>Quantity</code> <p>The wavelength at which the cross-section is measured.</p> required <code>cross_section</code> <code>Quantity</code> <p>The cross-section value at the given wavelength.</p> required Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def __init__(self, molecule: SpeciesFormula, wavelength: u.Quantity, cross_section: u.Quantity) -&gt; None:\n    \"\"\"Initialize and load the cross-section data.\n\n    Args:\n        molecule: The molecule for which the cross-section is loaded.\n        wavelength: The wavelength at which the cross-section is measured.\n        cross_section: The cross-section value at the given wavelength.\n\n    \"\"\"\n    self.wavelength = wavelength\n    self.cross_section = cross_section\n    self.molecule = molecule\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.CrossSection.interp_to","title":"<code>interp_to(wavelength, temperature, pressure)</code>","text":"<p>Interpolate the cross section to the given wavelength, temperature and pressure</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Quantity</code> <p>The wavelength to which the cross section is interpolated.</p> required <code>temperature</code> <code>Quantity</code> <p>The temperature at which the cross section is measured.</p> required <code>pressure</code> <code>Quantity</code> <p>The pressure at which the cross section is measured.</p> required <p>Returns:</p> Name Type Description <code>CrossSection</code> <code>CrossSection</code> <p>A new CrossSection object with the interpolated values.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def interp_to(self, wavelength: u.Quantity, temperature: u.Quantity, pressure: u.Quantity) -&gt; \"CrossSection\":\n    \"\"\"Interpolate the cross section to the given wavelength, temperature and pressure\n\n    Args:\n        wavelength: The wavelength to which the cross section is interpolated.\n        temperature: The temperature at which the cross section is measured.\n        pressure: The pressure at which the cross section is measured.\n\n    Returns:\n        CrossSection: A new CrossSection object with the interpolated values.\n\n\n    \"\"\"\n\n    new_wavelength = self.wavelength.to(wavelength.unit, equivalencies=u.spectral())\n\n    return CrossSection(\n        self.molecule,\n        wavelength,\n        np.interp(wavelength.value, new_wavelength.value, self.cross_section.value, left=0.0, right=0.0)\n        &lt;&lt; self.cross_section.unit,\n    )\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoMolecule","title":"<code>PhotoMolecule</code>","text":"<p>Represents a molecule used in photodissociation reactions.</p> <p>This class contains the cross-section data and quantum yields for the molecule.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>class PhotoMolecule:\n    \"\"\"Represents a molecule used in photodissociation reactions.\n\n    This class contains the cross-section data and quantum yields for the molecule.\n\n    \"\"\"\n\n    def __init__(self, molecule: SpeciesFormula, cross_section: CrossSection):\n        \"\"\"Initialize the PhotoMolecule with a molecule and its cross-section.\n\n        Args:\n            molecule: The molecule for which the cross-section is loaded.\n            cross_section: The cross-section data for the molecule.\n\n\n\n        \"\"\"\n        self.molecule = molecule\n        self.cross_section = cross_section\n        self.quantum_yields: dict[str | int, QuantumYield] = {}\n\n    def add_quantum_yield(self, branch_id: int | str, quantum_yield: QuantumYield):\n        \"\"\"Add a quantum yield to the molecule.\n\n        Will interpolate the quantum yield to the cross-section wavelength.\n\n        Args:\n            branch_id: The ID of the branching ratio.\n            quantum_yield: The quantum yield data to be added.\n\n\n        \"\"\"\n        self.quantum_yields[branch_id] = quantum_yield.interp_to(self.cross_section.wavelength)\n\n    def get_quantum_yield(self, branch_id: int | str) -&gt; QuantumYield:\n        \"\"\"Get the quantum yield for a given branch.\n\n        If the quantum yield is not found, a default quantum yield of 1.0 is returned.\n\n        Args:\n            branch_id: The ID of the branching ratio.\n        Returns:\n            QuantumYield: The quantum yield data for the given branch.\n\n\n        \"\"\"\n\n        if branch_id not in self.quantum_yields:\n            return QuantumYield(\n                self.molecule, branch_id, self.cross_section.wavelength, np.ones(self.cross_section.wavelength.shape)\n            )\n\n        return self.quantum_yields[branch_id]\n\n    def interp_to(self, wavelength: u.Quantity, temperature: u.Quantity, pressure: u.Quantity) -&gt; \"PhotoMolecule\":\n        \"\"\"Interpolate the cross section and quantum yields to the given wavelength.\n\n        Args:\n            wavelength: The wavelength to which the cross section and quantum yields are interpolated.\n\n        Returns:\n            PhotoMolecule: A new PhotoMolecule object with the interpolated values.\n\n\n        \"\"\"\n\n        new_cross_section = self.cross_section.interp_to(wavelength, temperature, pressure)\n        new_molecule = PhotoMolecule(self.molecule, new_cross_section)\n\n        for branch_id, qy in self.quantum_yields.items():\n            new_molecule.add_quantum_yield(branch_id, qy.interp_to(wavelength))\n\n        return new_molecule\n\n    def reaction_rate(self, branch_id: int | str, flux: u.Quantity) -&gt; list[FreckllArray]:\n        r\"\"\"Compute the reaction rate for a given branch.\n\n        Calculates the integral:\n\n        $$\n        R = \\int \\sigma(\\lambda) \\cdot QY(\\lambda) \\cdot F(\\lambda) d\\lambda\n        $$\n\n        where:\n        - $R$ is the reaction rate\n        - $\\sigma(\\lambda)$ is the cross-section\n        - $QY(\\lambda)$ is the quantum yield\n        - $F(\\lambda)$ is the flux\n        The integral is computed over the wavelength range of the cross-section.\n\n        Args:\n            branch_id: The ID of the branching ratio.\n            flux: The flux at which the reaction rate is computed.\n\n        Returns:\n            u.Quantity: The reaction rate for the given branch.\n\n\n        \"\"\"\n        qy = self.get_quantum_yield(branch_id)\n        flux = flux.to(u.photon / u.cm**2 / u.s / u.nm, equivalencies=u.spectral_density(self.cross_section.wavelength))\n        reaction_rate = (\n            np.trapezoid(qy.qy * self.cross_section.cross_section * flux, self.cross_section.wavelength, axis=-1)\n            / u.photon\n        )\n        return reaction_rate.to(1 / (u.s)).value\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoMolecule.__init__","title":"<code>__init__(molecule, cross_section)</code>","text":"<p>Initialize the PhotoMolecule with a molecule and its cross-section.</p> <p>Parameters:</p> Name Type Description Default <code>molecule</code> <code>SpeciesFormula</code> <p>The molecule for which the cross-section is loaded.</p> required <code>cross_section</code> <code>CrossSection</code> <p>The cross-section data for the molecule.</p> required Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def __init__(self, molecule: SpeciesFormula, cross_section: CrossSection):\n    \"\"\"Initialize the PhotoMolecule with a molecule and its cross-section.\n\n    Args:\n        molecule: The molecule for which the cross-section is loaded.\n        cross_section: The cross-section data for the molecule.\n\n\n\n    \"\"\"\n    self.molecule = molecule\n    self.cross_section = cross_section\n    self.quantum_yields: dict[str | int, QuantumYield] = {}\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoMolecule.add_quantum_yield","title":"<code>add_quantum_yield(branch_id, quantum_yield)</code>","text":"<p>Add a quantum yield to the molecule.</p> <p>Will interpolate the quantum yield to the cross-section wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>branch_id</code> <code>int | str</code> <p>The ID of the branching ratio.</p> required <code>quantum_yield</code> <code>QuantumYield</code> <p>The quantum yield data to be added.</p> required Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def add_quantum_yield(self, branch_id: int | str, quantum_yield: QuantumYield):\n    \"\"\"Add a quantum yield to the molecule.\n\n    Will interpolate the quantum yield to the cross-section wavelength.\n\n    Args:\n        branch_id: The ID of the branching ratio.\n        quantum_yield: The quantum yield data to be added.\n\n\n    \"\"\"\n    self.quantum_yields[branch_id] = quantum_yield.interp_to(self.cross_section.wavelength)\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoMolecule.get_quantum_yield","title":"<code>get_quantum_yield(branch_id)</code>","text":"<p>Get the quantum yield for a given branch.</p> <p>If the quantum yield is not found, a default quantum yield of 1.0 is returned.</p> <p>Parameters:</p> Name Type Description Default <code>branch_id</code> <code>int | str</code> <p>The ID of the branching ratio.</p> required <p>Returns:     QuantumYield: The quantum yield data for the given branch.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def get_quantum_yield(self, branch_id: int | str) -&gt; QuantumYield:\n    \"\"\"Get the quantum yield for a given branch.\n\n    If the quantum yield is not found, a default quantum yield of 1.0 is returned.\n\n    Args:\n        branch_id: The ID of the branching ratio.\n    Returns:\n        QuantumYield: The quantum yield data for the given branch.\n\n\n    \"\"\"\n\n    if branch_id not in self.quantum_yields:\n        return QuantumYield(\n            self.molecule, branch_id, self.cross_section.wavelength, np.ones(self.cross_section.wavelength.shape)\n        )\n\n    return self.quantum_yields[branch_id]\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoMolecule.interp_to","title":"<code>interp_to(wavelength, temperature, pressure)</code>","text":"<p>Interpolate the cross section and quantum yields to the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Quantity</code> <p>The wavelength to which the cross section and quantum yields are interpolated.</p> required <p>Returns:</p> Name Type Description <code>PhotoMolecule</code> <code>PhotoMolecule</code> <p>A new PhotoMolecule object with the interpolated values.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def interp_to(self, wavelength: u.Quantity, temperature: u.Quantity, pressure: u.Quantity) -&gt; \"PhotoMolecule\":\n    \"\"\"Interpolate the cross section and quantum yields to the given wavelength.\n\n    Args:\n        wavelength: The wavelength to which the cross section and quantum yields are interpolated.\n\n    Returns:\n        PhotoMolecule: A new PhotoMolecule object with the interpolated values.\n\n\n    \"\"\"\n\n    new_cross_section = self.cross_section.interp_to(wavelength, temperature, pressure)\n    new_molecule = PhotoMolecule(self.molecule, new_cross_section)\n\n    for branch_id, qy in self.quantum_yields.items():\n        new_molecule.add_quantum_yield(branch_id, qy.interp_to(wavelength))\n\n    return new_molecule\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoMolecule.reaction_rate","title":"<code>reaction_rate(branch_id, flux)</code>","text":"<p>Compute the reaction rate for a given branch.</p> <p>Calculates the integral:</p> \\[ R = \\int \\sigma(\\lambda) \\cdot QY(\\lambda) \\cdot F(\\lambda) d\\lambda \\] <p>where: - \\(R\\) is the reaction rate - \\(\\sigma(\\lambda)\\) is the cross-section - \\(QY(\\lambda)\\) is the quantum yield - \\(F(\\lambda)\\) is the flux The integral is computed over the wavelength range of the cross-section.</p> <p>Parameters:</p> Name Type Description Default <code>branch_id</code> <code>int | str</code> <p>The ID of the branching ratio.</p> required <code>flux</code> <code>Quantity</code> <p>The flux at which the reaction rate is computed.</p> required <p>Returns:</p> Type Description <code>list[FreckllArray]</code> <p>u.Quantity: The reaction rate for the given branch.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def reaction_rate(self, branch_id: int | str, flux: u.Quantity) -&gt; list[FreckllArray]:\n    r\"\"\"Compute the reaction rate for a given branch.\n\n    Calculates the integral:\n\n    $$\n    R = \\int \\sigma(\\lambda) \\cdot QY(\\lambda) \\cdot F(\\lambda) d\\lambda\n    $$\n\n    where:\n    - $R$ is the reaction rate\n    - $\\sigma(\\lambda)$ is the cross-section\n    - $QY(\\lambda)$ is the quantum yield\n    - $F(\\lambda)$ is the flux\n    The integral is computed over the wavelength range of the cross-section.\n\n    Args:\n        branch_id: The ID of the branching ratio.\n        flux: The flux at which the reaction rate is computed.\n\n    Returns:\n        u.Quantity: The reaction rate for the given branch.\n\n\n    \"\"\"\n    qy = self.get_quantum_yield(branch_id)\n    flux = flux.to(u.photon / u.cm**2 / u.s / u.nm, equivalencies=u.spectral_density(self.cross_section.wavelength))\n    reaction_rate = (\n        np.trapezoid(qy.qy * self.cross_section.cross_section * flux, self.cross_section.wavelength, axis=-1)\n        / u.photon\n    )\n    return reaction_rate.to(1 / (u.s)).value\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoReactionCall","title":"<code>PhotoReactionCall</code>","text":"Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>class PhotoReactionCall:\n    def __init__(\n        self,\n        reactant: PhotoMolecule,\n        products: list[SpeciesFormula],\n        branch_id: int | str,\n        species_list: t.Optional[list[SpeciesFormula]] = None,\n        reactant_index: t.Optional[int] = None,\n        product_indices: t.Optional[npt.NDArray[np.integer]] = None,\n        tags: t.Optional[list[str]] = None,\n    ):\n        \"\"\"Initialize the photodissociation reaction call.\n\n        Args:\n            reactant: The reactant of the reaction.\n            products: The products of the reaction.\n            branch_id: The ID of the branching ratio.\n            species_list: The list of species in the network.\n            reactant_index: The index of the reactant in the species list.\n            product_indices: The indices of the products in the species list.\n            tags: The tags associated with the reaction.\n\n        \"\"\"\n        self.reactant = reactant\n        self.products = products\n        self.tags = tags if tags is not None else [\"photodissociation\"]\n\n        self.reactant_index = reactant_index\n        if self.reactant_index is None:\n            self.reactant_index = species_list.index(reactant.molecule)\n        self.product_indices = product_indices\n        if self.product_indices is None:\n            self.product_indices = np.array([species_list.index(p) for p in products], dtype=np.int64)\n        self.branch_id = branch_id\n        self.tags = list(set(self.tags))\n\n    def interpolate_to(\n        self,\n        wavelength: u.Quantity,\n        temperature: u.Quantity | None = None,\n        pressure: u.Quantity | None = None,\n    ) -&gt; \"PhotoReactionCall\":\n        \"\"\"Interpolate the reaction call to the given wavelength.\n\n        Args:\n            wavelength: The wavelength to which the reaction call is interpolated.\n\n        Returns:\n            PhotoReactionCall: A new PhotoReactionCall object with the interpolated values.\n\n\n        \"\"\"\n        reactant = self.reactant.interp_to(wavelength, temperature, pressure)\n\n        return PhotoReactionCall(\n            reactant,\n            self.products,\n            self.branch_id,\n            reactant_index=self.reactant_index,\n            product_indices=self.product_indices,\n            tags=self.tags,\n        )\n\n    @property\n    def molecule(self) -&gt; SpeciesFormula:\n        \"\"\"Return the molecule of the reactant.\"\"\"\n        return self.reactant.molecule\n\n    @property\n    def cross_section(self) -&gt; CrossSection:\n        \"\"\"Return the cross-section of the reactant.\"\"\"\n        return self.reactant.cross_section\n\n    def __call__(self, flux: u.Quantity, number_density: FreckllArray) -&gt; Reaction:\n        \"\"\"Call the reaction.\n\n        This method computes the reaction rate and creates a Reaction object.\n\n        Args:\n            flux: The flux at which the reaction is computed.\n            number_density: The number density of the reactant.\n\n\n        Returns:\n            Reaction: The reaction object representing the photodissociation reaction.\n\n        \"\"\"\n        reaction_rate = self.reactant.reaction_rate(self.branch_id, flux)\n\n        reaction = Reaction(\n            reactants=[self.reactant.molecule],\n            products=self.products,\n            reactants_indices=np.array([self.reactant_index]),\n            product_indices=self.product_indices,\n            reaction_rate=reaction_rate,\n            tags=self.tags,\n        )\n\n        reaction.calculate_density_krate(number_density.to(u.cm**-3).value)\n\n        return [reaction]\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoReactionCall.cross_section","title":"<code>cross_section</code>  <code>property</code>","text":"<p>Return the cross-section of the reactant.</p>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoReactionCall.molecule","title":"<code>molecule</code>  <code>property</code>","text":"<p>Return the molecule of the reactant.</p>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoReactionCall.__call__","title":"<code>__call__(flux, number_density)</code>","text":"<p>Call the reaction.</p> <p>This method computes the reaction rate and creates a Reaction object.</p> <p>Parameters:</p> Name Type Description Default <code>flux</code> <code>Quantity</code> <p>The flux at which the reaction is computed.</p> required <code>number_density</code> <code>FreckllArray</code> <p>The number density of the reactant.</p> required <p>Returns:</p> Name Type Description <code>Reaction</code> <code>Reaction</code> <p>The reaction object representing the photodissociation reaction.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def __call__(self, flux: u.Quantity, number_density: FreckllArray) -&gt; Reaction:\n    \"\"\"Call the reaction.\n\n    This method computes the reaction rate and creates a Reaction object.\n\n    Args:\n        flux: The flux at which the reaction is computed.\n        number_density: The number density of the reactant.\n\n\n    Returns:\n        Reaction: The reaction object representing the photodissociation reaction.\n\n    \"\"\"\n    reaction_rate = self.reactant.reaction_rate(self.branch_id, flux)\n\n    reaction = Reaction(\n        reactants=[self.reactant.molecule],\n        products=self.products,\n        reactants_indices=np.array([self.reactant_index]),\n        product_indices=self.product_indices,\n        reaction_rate=reaction_rate,\n        tags=self.tags,\n    )\n\n    reaction.calculate_density_krate(number_density.to(u.cm**-3).value)\n\n    return [reaction]\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoReactionCall.__init__","title":"<code>__init__(reactant, products, branch_id, species_list=None, reactant_index=None, product_indices=None, tags=None)</code>","text":"<p>Initialize the photodissociation reaction call.</p> <p>Parameters:</p> Name Type Description Default <code>reactant</code> <code>PhotoMolecule</code> <p>The reactant of the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>branch_id</code> <code>int | str</code> <p>The ID of the branching ratio.</p> required <code>species_list</code> <code>Optional[list[SpeciesFormula]]</code> <p>The list of species in the network.</p> <code>None</code> <code>reactant_index</code> <code>Optional[int]</code> <p>The index of the reactant in the species list.</p> <code>None</code> <code>product_indices</code> <code>Optional[NDArray[integer]]</code> <p>The indices of the products in the species list.</p> <code>None</code> <code>tags</code> <code>Optional[list[str]]</code> <p>The tags associated with the reaction.</p> <code>None</code> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def __init__(\n    self,\n    reactant: PhotoMolecule,\n    products: list[SpeciesFormula],\n    branch_id: int | str,\n    species_list: t.Optional[list[SpeciesFormula]] = None,\n    reactant_index: t.Optional[int] = None,\n    product_indices: t.Optional[npt.NDArray[np.integer]] = None,\n    tags: t.Optional[list[str]] = None,\n):\n    \"\"\"Initialize the photodissociation reaction call.\n\n    Args:\n        reactant: The reactant of the reaction.\n        products: The products of the reaction.\n        branch_id: The ID of the branching ratio.\n        species_list: The list of species in the network.\n        reactant_index: The index of the reactant in the species list.\n        product_indices: The indices of the products in the species list.\n        tags: The tags associated with the reaction.\n\n    \"\"\"\n    self.reactant = reactant\n    self.products = products\n    self.tags = tags if tags is not None else [\"photodissociation\"]\n\n    self.reactant_index = reactant_index\n    if self.reactant_index is None:\n        self.reactant_index = species_list.index(reactant.molecule)\n    self.product_indices = product_indices\n    if self.product_indices is None:\n        self.product_indices = np.array([species_list.index(p) for p in products], dtype=np.int64)\n    self.branch_id = branch_id\n    self.tags = list(set(self.tags))\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.PhotoReactionCall.interpolate_to","title":"<code>interpolate_to(wavelength, temperature=None, pressure=None)</code>","text":"<p>Interpolate the reaction call to the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Quantity</code> <p>The wavelength to which the reaction call is interpolated.</p> required <p>Returns:</p> Name Type Description <code>PhotoReactionCall</code> <code>PhotoReactionCall</code> <p>A new PhotoReactionCall object with the interpolated values.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def interpolate_to(\n    self,\n    wavelength: u.Quantity,\n    temperature: u.Quantity | None = None,\n    pressure: u.Quantity | None = None,\n) -&gt; \"PhotoReactionCall\":\n    \"\"\"Interpolate the reaction call to the given wavelength.\n\n    Args:\n        wavelength: The wavelength to which the reaction call is interpolated.\n\n    Returns:\n        PhotoReactionCall: A new PhotoReactionCall object with the interpolated values.\n\n\n    \"\"\"\n    reactant = self.reactant.interp_to(wavelength, temperature, pressure)\n\n    return PhotoReactionCall(\n        reactant,\n        self.products,\n        self.branch_id,\n        reactant_index=self.reactant_index,\n        product_indices=self.product_indices,\n        tags=self.tags,\n    )\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.QuantumYield","title":"<code>QuantumYield</code>","text":"<p>Loads quantum yield data for molecule.</p> <p>This represents the branching ratio of the photodissociation process.</p> <p>This is generic and it is up to the chemical network to determine how branching ratios are organised</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>class QuantumYield:\n    \"\"\"Loads quantum yield data for molecule.\n\n    This represents the branching ratio of the photodissociation process.\n\n    This is generic and it is up to the chemical network to determine how branching ratios\n    are organised\n\n    \"\"\"\n\n    def __init__(\n        self, molecule: SpeciesFormula, branch_id: int | str, wavelength: u.Quantity, qy: npt.NDArray[np.float64]\n    ):\n        \"\"\"Initialize and load the quantum yield data.\n\n        Args:\n            molecule: The molecule for which the quantum yield is loaded.\n            branch_id: The ID of the branching ratio.\n            wavelength: The wavelength at which the quantum yield is measured.\n            qy: The quantum yield value at the given wavelength.\n        \"\"\"\n        self.wavelength = wavelength\n        self.qy = qy\n        self.molecule = molecule\n        self.branch_id = branch_id\n\n    def interp_to(self, wavelength: u.Quantity) -&gt; \"QuantumYield\":\n        \"\"\"Interpolate the quantum yield to the given wavelength.\n\n        Args:\n            wavelength: The wavelength to which the quantum yield is interpolated.\n\n        Returns:\n            QuantumYield: A new QuantumYield object with the interpolated values.\n\n        \"\"\"\n\n        new_wavelength = self.wavelength.to(wavelength.unit, equivalencies=u.spectral())\n\n        return QuantumYield(\n            self.molecule,\n            self.branch_id,\n            wavelength,\n            np.interp(wavelength.value, new_wavelength.value, self.qy, left=0.0, right=0.0),\n        )\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.QuantumYield.__init__","title":"<code>__init__(molecule, branch_id, wavelength, qy)</code>","text":"<p>Initialize and load the quantum yield data.</p> <p>Parameters:</p> Name Type Description Default <code>molecule</code> <code>SpeciesFormula</code> <p>The molecule for which the quantum yield is loaded.</p> required <code>branch_id</code> <code>int | str</code> <p>The ID of the branching ratio.</p> required <code>wavelength</code> <code>Quantity</code> <p>The wavelength at which the quantum yield is measured.</p> required <code>qy</code> <code>NDArray[float64]</code> <p>The quantum yield value at the given wavelength.</p> required Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def __init__(\n    self, molecule: SpeciesFormula, branch_id: int | str, wavelength: u.Quantity, qy: npt.NDArray[np.float64]\n):\n    \"\"\"Initialize and load the quantum yield data.\n\n    Args:\n        molecule: The molecule for which the quantum yield is loaded.\n        branch_id: The ID of the branching ratio.\n        wavelength: The wavelength at which the quantum yield is measured.\n        qy: The quantum yield value at the given wavelength.\n    \"\"\"\n    self.wavelength = wavelength\n    self.qy = qy\n    self.molecule = molecule\n    self.branch_id = branch_id\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.QuantumYield.interp_to","title":"<code>interp_to(wavelength)</code>","text":"<p>Interpolate the quantum yield to the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Quantity</code> <p>The wavelength to which the quantum yield is interpolated.</p> required <p>Returns:</p> Name Type Description <code>QuantumYield</code> <code>QuantumYield</code> <p>A new QuantumYield object with the interpolated values.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def interp_to(self, wavelength: u.Quantity) -&gt; \"QuantumYield\":\n    \"\"\"Interpolate the quantum yield to the given wavelength.\n\n    Args:\n        wavelength: The wavelength to which the quantum yield is interpolated.\n\n    Returns:\n        QuantumYield: A new QuantumYield object with the interpolated values.\n\n    \"\"\"\n\n    new_wavelength = self.wavelength.to(wavelength.unit, equivalencies=u.spectral())\n\n    return QuantumYield(\n        self.molecule,\n        self.branch_id,\n        wavelength,\n        np.interp(wavelength.value, new_wavelength.value, self.qy, left=0.0, right=0.0),\n    )\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.StarSpectra","title":"<code>StarSpectra</code>","text":"Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>class StarSpectra:\n    def __init__(self, wavelength: u.Quantity, flux: u.Quantity, reference_distance: u.Quantity):\n        \"\"\"Initialize the star spectrum with wavelength and flux data.\n\n        Args:\n            wavelength: The wavelength of the star spectrum.\n            flux: The flux of the star spectrum.\n            reference_distance: The reference distance for the flux.\n\n        \"\"\"\n        self.wavelength = wavelength\n        self.flux = flux\n\n        self.reference_distance = reference_distance\n\n    def incident_flux(self, distance: u.Quantity) -&gt; u.Quantity:\n        r\"\"\"Calculate the flux density at the reference distance.\n\n\n        The flux density is calculated using the formula:\n        $$\n        F = F_0(\\frac{D_0}{d})^2$$\n        where:\n        - $F$ is the flux density at distance $d$\n        - $F_0$ is the flux density at reference distance $D_0$\n        - $d$ is the distance from the star\n        - $D_0$ is the reference distance\n\n\n        Returns:\n            u.Quantity: The flux density at the reference distance.\n\n        \"\"\"\n        return self.flux * (self.reference_distance / distance) ** 2 / 2\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.StarSpectra.__init__","title":"<code>__init__(wavelength, flux, reference_distance)</code>","text":"<p>Initialize the star spectrum with wavelength and flux data.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Quantity</code> <p>The wavelength of the star spectrum.</p> required <code>flux</code> <code>Quantity</code> <p>The flux of the star spectrum.</p> required <code>reference_distance</code> <code>Quantity</code> <p>The reference distance for the flux.</p> required Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def __init__(self, wavelength: u.Quantity, flux: u.Quantity, reference_distance: u.Quantity):\n    \"\"\"Initialize the star spectrum with wavelength and flux data.\n\n    Args:\n        wavelength: The wavelength of the star spectrum.\n        flux: The flux of the star spectrum.\n        reference_distance: The reference distance for the flux.\n\n    \"\"\"\n    self.wavelength = wavelength\n    self.flux = flux\n\n    self.reference_distance = reference_distance\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.StarSpectra.incident_flux","title":"<code>incident_flux(distance)</code>","text":"<p>Calculate the flux density at the reference distance.</p> <p>The flux density is calculated using the formula: $$ F = F_0(\\frac{D_0}{d})^2$$ where: - \\(F\\) is the flux density at distance \\(d\\) - \\(F_0\\) is the flux density at reference distance \\(D_0\\) - \\(d\\) is the distance from the star - \\(D_0\\) is the reference distance</p> <p>Returns:</p> Type Description <code>Quantity</code> <p>u.Quantity: The flux density at the reference distance.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def incident_flux(self, distance: u.Quantity) -&gt; u.Quantity:\n    r\"\"\"Calculate the flux density at the reference distance.\n\n\n    The flux density is calculated using the formula:\n    $$\n    F = F_0(\\frac{D_0}{d})^2$$\n    where:\n    - $F$ is the flux density at distance $d$\n    - $F_0$ is the flux density at reference distance $D_0$\n    - $d$ is the distance from the star\n    - $D_0$ is the reference distance\n\n\n    Returns:\n        u.Quantity: The flux density at the reference distance.\n\n    \"\"\"\n    return self.flux * (self.reference_distance / distance) ** 2 / 2\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.optical_depth","title":"<code>optical_depth(altitude, number_density, cross_sections, cross_section_indices)</code>","text":"<p>Compute the optical depth of the atmosphere.</p> <p>The optical depth is computed using the formula:</p> \\[ \\tau = \\int n(z) \\sigma(z) dz \\] <p>where:</p> <ul> <li>\\(\\tau\\) is the optical depth</li> <li>\\(n(z)\\) is the number density of the species at altitude \\(z\\)</li> <li>\\(\\sigma(z)\\) is the cross-section of the species at altitude \\(z\\)</li> </ul> <p>The integral is computed using the trapezoidal rule.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def optical_depth(\n    altitude: u.Quantity,\n    number_density: u.Quantity,\n    cross_sections: u.Quantity,\n    cross_section_indices: npt.NDArray[np.integer],\n) -&gt; FreckllArray:\n    r\"\"\"Compute the optical depth of the atmosphere.\n\n    The optical depth is computed using the formula:\n\n    $$\n    \\tau = \\int n(z) \\sigma(z) dz\n    $$\n\n    where:\n\n    - $\\tau$ is the optical depth\n    - $n(z)$ is the number density of the species at altitude $z$\n    - $\\sigma(z)$ is the cross-section of the species at altitude $z$\n\n    The integral is computed using the trapezoidal rule.\n\n\n\n    \"\"\"\n    dz = np.zeros_like(altitude)\n    dz[:-1] = np.diff(altitude)\n    dz[-1] = dz[-2]\n\n    number_density_dz = number_density * dz\n\n    cross_section_density = cross_sections[:, None, :] * number_density_dz[cross_section_indices, :, None]\n\n    tau = np.sum(cross_section_density, axis=0).decompose()\n\n    return tau\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.radiative_transfer","title":"<code>radiative_transfer(flux_top, optical_depth, incident_angle, albedo=0.0)</code>","text":"<p>Computes the radiative transfer equation.</p> <p>Computes the radiative transfer equation for a given flux and optical depth.</p> <p>The flux is then propagated upwards and downwards through the atmosphere. The albedo is taken into account for the upward flux.</p> <p>Parameters:</p> Name Type Description Default <code>flux_top</code> <code>Quantity</code> <p>The flux at the top of the atmosphere.</p> required <code>optical_depth</code> <code>FreckllArray</code> <p>The optical depth of the atmosphere.</p> required <code>incident_angle</code> <code>Quantity</code> <p>The angle of incidence.</p> required <code>albedo</code> <code>float | NDArray[float64]</code> <p>The albedo of the surface.</p> <code>0.0</code> <p>Returns:     u.Quantity: The total flux at each layer.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def radiative_transfer(\n    flux_top: u.Quantity,\n    optical_depth: FreckllArray,\n    incident_angle: u.Quantity,\n    albedo: float | npt.NDArray[np.float64] = 0.0,\n) -&gt; u.Quantity:\n    r\"\"\"Computes the radiative transfer equation.\n\n    Computes the radiative transfer equation for a given flux and optical depth.\n\n    The flux is then propagated upwards and downwards through the atmosphere.\n    The albedo is taken into account for the upward flux.\n\n\n    Args:\n        flux_top: The flux at the top of the atmosphere.\n        optical_depth: The optical depth of the atmosphere.\n        incident_angle: The angle of incidence.\n        albedo: The albedo of the surface.\n    Returns:\n        u.Quantity: The total flux at each layer.\n\n    \"\"\"\n\n    tau = np.exp(-optical_depth / np.cos(incident_angle))\n\n    flux_down = np.zeros_like(tau.value) &lt;&lt; flux_top.unit\n    flux_up = np.zeros_like(tau.value) &lt;&lt; flux_top.unit\n\n    flux_down[-1] = flux_top * tau[-1]\n    num_layers = flux_down.shape[0]\n    # Propagate the flux downwards from toa to boa\n    for layer in reversed(range(num_layers - 1)):\n        flux_down[layer] = flux_down[layer + 1] * tau[layer]\n\n    # If albedo then reflect the flux\n    flux_up[0] = flux_down[0] * albedo\n\n    # Propagate the flux upwards from boa to toa\n    for layer in range(1, num_layers):\n        flux_up[layer] = flux_up[layer - 1] * tau[layer - 1]\n\n    flux_down2 = np.zeros_like(flux_down)\n    flux_up2 = np.zeros_like(flux_up)\n\n    # Propagate the flux downwards from toa to boa\n    flux_down2[-1] = (0.5 * ((1 - tau[-1]) * (flux_up[-1] + flux_top)) + flux_top) * tau[-1]\n\n    flux_down2[-1] = (0.5 * ((1 - tau[-1]) * (flux_up[-1] + flux_top)) + flux_top) * tau[-1]\n    for layer in reversed(range(num_layers)[:-1]):\n        flux_down2[layer] = (\n            0.5 * ((1 - tau[layer]) * (flux_up[layer] + flux_down[layer + 1])) + flux_down2[layer + 1]\n        ) * tau[layer]\n\n    flux_up2[0] = albedo * flux_down2[0]\n    for layer in range(num_layers)[1:]:\n        flux_up2[layer] = (\n            0.5 * ((1 - tau[layer - 1]) * (flux_up[layer - 1] + flux_down[layer])) + flux_up2[layer - 1]\n        ) * tau[layer - 1]\n\n    return flux_up2 + flux_down2\n</code></pre>"},{"location":"modules/reactions/photolysis/#freckll.reactions.photo.rayleigh","title":"<code>rayleigh(spectral_grid, alpha, depolar_factor)</code>","text":"<p>Calculate the Rayleigh scattering cross-section.</p> <p>The Rayleigh scattering cross-section is given by the formula: $$ \\sigma_R = \\frac{8 \\pi^3}{3} \\left(\\frac{\\alpha}{\\lambda}\\right)^4 (1 + \\delta^2)$$</p> <p>where:</p> <ul> <li>\\(\\sigma_R\\) is the Rayleigh scattering cross-section</li> <li>\\(\\alpha\\) is the polarizability of the molecule</li> </ul> <p>Parameters:</p> Name Type Description Default <code>spectral_grid</code> <code>Quantity</code> <p>The wavelength grid.</p> required <code>alpha</code> <code>Quantity</code> <p>The polarizability of the molecule.</p> required <code>depolar_factor</code> <code>float</code> <p>The depolarization factor.</p> required <p>Returns:     u.Quantity: The Rayleigh scattering cross-section.</p> Source code in <code>src/freckll/reactions/photo.py</code> <pre><code>def rayleigh(spectral_grid: u.Quantity, alpha: u.Quantity, depolar_factor: float) -&gt; u.Quantity:\n    r\"\"\"Calculate the Rayleigh scattering cross-section.\n\n    The Rayleigh scattering cross-section is given by the formula:\n    $$\n    \\sigma_R = \\frac{8 \\pi^3}{3} \\left(\\frac{\\alpha}{\\lambda}\\right)^4 (1 + \\delta^2)$$\n\n    where:\n\n    - $\\sigma_R$ is the Rayleigh scattering cross-section\n    - $\\alpha$ is the polarizability of the molecule\n\n    Args:\n        spectral_grid: The wavelength grid.\n        alpha: The polarizability of the molecule.\n        depolar_factor: The depolarization factor.\n    Returns:\n        u.Quantity: The Rayleigh scattering cross-section.\n\n    \"\"\"\n\n    wavelength_cm = spectral_grid.to(u.cm, equivalencies=u.spectral())\n\n    alpha = alpha.to(u.cm**3)\n\n    return 8 * np.pi / 3 * (2 * np.pi / wavelength_cm) ** 4 * alpha**2 * depolar_factor\n</code></pre>"},{"location":"modules/reactions/reactions/","title":"Reactions","text":"<p>Reaction equations.</p>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.arrhenius_constant","title":"<code>arrhenius_constant(a, n, er, temperature)</code>","text":"<p>Computes Arrhenius rate constants for low and high pressure limits.</p> <p>Formula is as follows:</p> \\[ k = A T^n \\exp(-E_r/T) \\] <p>where: - \\(k\\) is the rate constant - \\(A\\) is the pre-exponential factor - \\(T\\) is the temperature - \\(n\\) is the temperature exponent - \\(E_r\\) is the activation energy - \\(k\\) is the rate constant</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float | FreckllArray</code> <p>The pre-exponential factor.</p> required <code>n</code> <code>float | FreckllArray</code> <p>The temperature exponent</p> required <code>er</code> <code>float | FreckllArray</code> <p>The activation energy.</p> required <p>Returns:</p> Name Type Description <code>k</code> <code>FreckllArray</code> <p>The rate constant of the reaction.</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def arrhenius_constant(\n    a: float | FreckllArray,\n    n: float | FreckllArray,\n    er: float | FreckllArray,\n    temperature: FreckllArray,\n) -&gt; FreckllArray:\n    r\"\"\"Computes Arrhenius rate constants for low and high pressure limits.\n\n    Formula is as follows:\n\n    $$\n    k = A T^n \\exp(-E_r/T)\n    $$\n\n    where:\n    - $k$ is the rate constant\n    - $A$ is the pre-exponential factor\n    - $T$ is the temperature\n    - $n$ is the temperature exponent\n    - $E_r$ is the activation energy\n    - $k$ is the rate constant\n\n    Args:\n        a: The pre-exponential factor.\n        n: The temperature exponent\n        er: The activation energy.\n\n    Returns:\n        k: The rate constant of the reaction.\n\n    \"\"\"\n    return t.cast(FreckllArray, (a * temperature**n) * np.exp(-er / temperature))\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.corps_reaction","title":"<code>corps_reaction(k0_coeffs, invert, reactants, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>Many body reaction rate constant.</p> <p>Parameters:</p> Name Type Description Default <code>k0_coeffs</code> <code>list[float]</code> <p>The low-pressure rate constant coefficients.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants of the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Type Description <code>ReactionFunction</code> <p>A function that takes the concentration of the species and returns the rate</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def corps_reaction(\n    k0_coeffs: list[float],\n    invert: bool,\n    reactants: list[SpeciesFormula],\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; ReactionFunction:\n    \"\"\"Many body reaction rate constant.\n\n\n    Args:\n        k0_coeffs: The low-pressure rate constant coefficients.\n        invert: Whether to invert the reaction.\n        reactants: The reactants of the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        A function that takes the concentration of the species and returns the rate\n\n    \"\"\"\n    a0, n0, er0, _, _ = k0_coeffs\n\n    k0 = arrhenius_constant(a0, n0, er0, temperature)\n\n    def _react(\n        concentration: FreckllArray,\n        k0: FreckllArray = k0,\n        reactants: list[SpeciesFormula] = reactants,\n        products: list[SpeciesFormula] = products,\n        temperature: FreckllArray = temperature,\n        thermo_reactants: FreckllArray = thermo_reactants,\n        thermo_products: FreckllArray = thermo_products,\n        invert: bool = invert,\n    ) -&gt; list[FreckllArray]:\n        k_rate = np.copy(k0)\n        m = np.sum(concentration, axis=0)\n\n        if len(reactants) &lt; 3:\n            k_rate = collision_rate_limit(reactants, k_rate, np.zeros_like(k0), m, temperature)\n\n        if invert:\n            k0inv, _, keq = invert_reaction(thermo_products, thermo_reactants, k0, np.zeros_like(k0), temperature)\n\n            inv_k_rate = k0inv\n\n            if len(products) &gt; 1:\n                inv_k_rate_coll = collision_rate_limit(products, inv_k_rate, np.zeros_like(k0), m, temperature)\n\n                check_rate = k0inv != inv_k_rate_coll\n\n                k_rate[check_rate] = inv_k_rate_coll[check_rate] * keq[check_rate]\n\n                inv_k_rate = inv_k_rate_coll\n            return [k_rate, inv_k_rate]\n\n        return [k_rate]\n\n    return _react\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.de_excitation_reaction","title":"<code>de_excitation_reaction(k0_coeffs, efficiency, invert, reactants, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>De-excitation reaction rate constant.</p> <p>Parameters:</p> Name Type Description Default <code>k0_coeffs</code> <code>list[float]</code> <p>The low-pressure rate constant coefficients.</p> required <code>efficiency</code> <code>FreckllArray</code> <p>The efficiency of the reaction.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants of the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Type Description <code>ReactionFunction</code> <p>A function that takes the concentration of the species and returns the rate</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def de_excitation_reaction(\n    k0_coeffs: list[float],\n    efficiency: FreckllArray,\n    invert: bool,\n    reactants: list[SpeciesFormula],\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; ReactionFunction:\n    \"\"\"De-excitation reaction rate constant.\n\n    Args:\n        k0_coeffs: The low-pressure rate constant coefficients.\n        efficiency: The efficiency of the reaction.\n        invert: Whether to invert the reaction.\n        reactants: The reactants of the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        A function that takes the concentration of the species and returns the rate\n\n    \"\"\"\n    a0, n0, er0, _, _ = k0_coeffs\n\n    k0 = arrhenius_constant(a0, n0, er0, temperature)\n\n    def _react(\n        concentration: FreckllArray,\n        efficiency: FreckllArray = efficiency,\n        reactants: list[SpeciesFormula] = reactants,\n        k0: FreckllArray = k0,\n        temperature: FreckllArray = temperature,\n        thermo_reactants: FreckllArray = thermo_reactants,\n        thermo_products: FreckllArray = thermo_products,\n    ) -&gt; FreckllArray:\n        m = np.sum(concentration * efficiency[:, None], axis=0)\n\n        k0 = collision_rate_limit(reactants, k0, np.zeros_like(k0), m, temperature)\n\n        k_rate = k0 * m\n        if invert:\n            k0inv, _, keq = invert_reaction(thermo_products, thermo_reactants, k0, np.zeros_like(k0), temperature)\n\n            inv_k_rate = k0inv * m\n            k0inv_coll = collision_rate_limit(products, k0inv, np.zeros_like(k0), m, temperature)\n            inv_k_rate_coll = k0inv_coll * m\n            check_rate = inv_k_rate != inv_k_rate_coll\n\n            k_rate[check_rate] = inv_k_rate_coll[check_rate] * keq[check_rate]\n            inv_k_rate = inv_k_rate_coll\n\n            return [k_rate, inv_k_rate]\n\n        return [k_rate]\n\n    return _react\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.decomposition_k0_reaction","title":"<code>decomposition_k0_reaction(k0_coeffs, efficiency, invert, reactants, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>Decomposition reaction rate constant.</p> <p>Parameters:</p> Name Type Description Default <code>k0_coeffs</code> <code>list[float]</code> <p>The low-pressure rate constant coefficients.</p> required <code>efficiency</code> <code>FreckllArray</code> <p>The efficiency of the reaction.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants of the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Type Description <code>ReactionFunction</code> <p>A function that takes the concentration of the species and returns the rate</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def decomposition_k0_reaction(\n    k0_coeffs: list[float],\n    efficiency: FreckllArray,\n    invert: bool,\n    reactants: list[SpeciesFormula],\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; ReactionFunction:\n    \"\"\"Decomposition reaction rate constant.\n\n    Args:\n        k0_coeffs: The low-pressure rate constant coefficients.\n        efficiency: The efficiency of the reaction.\n        invert: Whether to invert the reaction.\n        reactants: The reactants of the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        A function that takes the concentration of the species and returns the rate\n\n    \"\"\"\n    a0, n0, er0, _, _ = k0_coeffs\n\n    k0 = arrhenius_constant(a0, n0, er0, temperature)\n\n    def _react(\n        concentration: FreckllArray,\n        k0: FreckllArray = k0,\n        efficiency: FreckllArray = efficiency,\n        reactants: list[SpeciesFormula] = reactants,\n        products: list[SpeciesFormula] = products,\n        temperature: FreckllArray = temperature,\n        thermo_reactants: FreckllArray = thermo_reactants,\n        thermo_products: FreckllArray = thermo_products,\n        invert: bool = invert,\n    ) -&gt; list[FreckllArray]:\n        m = np.sum(concentration * efficiency[:, None], axis=0)\n        k0 = collision_rate_limit(reactants, k0, np.zeros_like(k0), m, temperature)\n        k_rate = k0 * m\n\n        if invert:\n            k0inv, _, keq = invert_reaction(thermo_products, thermo_reactants, k0, np.zeros_like(k0), temperature)\n\n            inv_k_rate = k0inv * m\n\n            inv_k_rate_coll = collision_rate_limit(products, inv_k_rate, np.zeros_like(k0), m, temperature)\n\n            check_rate = inv_k_rate != inv_k_rate_coll\n\n            k_rate[check_rate] = inv_k_rate_coll[check_rate] * keq[check_rate]\n            inv_k_rate = inv_k_rate_coll\n            return [k_rate, inv_k_rate]\n\n        return [k_rate]\n\n    return _react\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.decomposition_k0kinf_reaction","title":"<code>decomposition_k0kinf_reaction(k0_coeffs, kinf_coeffs, falloff_coeffs, efficiency, invert, falloff_function, reactants, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>Decomposition reaction rate constant.</p> <p>This the Arrheniues rate with the low-pressure and high pressure limits The low pressure limit is: $$ k_0 = A_0 T^{n_0} \\exp(-E_{r0}/T) $$ The high pressure limit is: $$ k_\\infty = A_i T^{n_i} \\exp(-E_{ri}/T) $$</p> <p>Additionally you can also provide a falloff function to calculate the falloff term.</p> <p>Parameters:</p> Name Type Description Default <code>k0_coeffs</code> <code>list[float]</code> <p>The low-pressure rate constant coefficients.</p> required <code>kinf_coeffs</code> <code>list[float]</code> <p>The high-pressure rate constant coefficients.</p> required <code>falloff_coeffs</code> <code>list[float]</code> <p>The falloff coefficients.</p> required <code>efficiency</code> <code>FreckllArray</code> <p>The efficiency of the reaction.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>falloff_function</code> <code>FalloffFunction</code> <p>The falloff function to use.</p> required <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants of the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Type Description <code>ReactionFunction</code> <p>A function that takes the concentration of the species and returns the rate</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def decomposition_k0kinf_reaction(\n    k0_coeffs: list[float],\n    kinf_coeffs: list[float],\n    falloff_coeffs: list[float],\n    efficiency: FreckllArray,\n    invert: bool,\n    falloff_function: FalloffFunction,\n    reactants: list[SpeciesFormula],\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; ReactionFunction:\n    r\"\"\"Decomposition reaction rate constant.\n\n\n    This the Arrheniues rate with the low-pressure and high pressure\n    limits\n    The low pressure limit is:\n    $$\n    k_0 = A_0 T^{n_0} \\exp(-E_{r0}/T)\n    $$\n    The high pressure limit is:\n    $$\n    k_\\infty = A_i T^{n_i} \\exp(-E_{ri}/T)\n    $$\n\n    Additionally you can also provide a falloff function to calculate\n    the falloff term.\n\n    Args:\n        k0_coeffs: The low-pressure rate constant coefficients.\n        kinf_coeffs: The high-pressure rate constant coefficients.\n        falloff_coeffs: The falloff coefficients.\n        efficiency: The efficiency of the reaction.\n        invert: Whether to invert the reaction.\n        falloff_function: The falloff function to use.\n        reactants: The reactants of the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        A function that takes the concentration of the species and returns the rate\n\n    \"\"\"\n    # k0 terms\n    a0, n0, er0, _, _ = k0_coeffs\n    # kinf terms\n    ai, ni, eri, _, _ = kinf_coeffs\n\n    # Falloff terms\n    unimolecular = len(reactants) == 1 or len(products) == 1\n\n    k0 = arrhenius_constant(a0, n0, er0, temperature)\n    kinf = arrhenius_constant(ai, ni, eri, temperature)\n\n    def _react(\n        concentration: FreckllArray,\n        efficiency: FreckllArray = efficiency,\n        k0: FreckllArray = k0,\n        kinf: FreckllArray = kinf,\n        falloff_function: FalloffFunction = falloff_function,\n        reactants: list[SpeciesFormula] = reactants,\n        products: list[SpeciesFormula] = products,\n        temperature: FreckllArray = temperature,\n        falloff_coeffs: list[float] = falloff_coeffs,\n        invert: bool = invert,\n        unimolecular: bool = unimolecular,\n    ):\n        m: FreckllArray = (efficiency[:, None] * concentration).sum(axis=0)\n\n        k0 = collision_rate_limit(reactants, k0, kinf, m, temperature)\n\n        falloff = falloff_function(\n            k0,\n            kinf,\n            m,\n            temperature,\n            *falloff_coeffs,\n        )\n\n        k_rate = k0 * falloff / (1 + k0 * m / kinf)\n\n        if unimolecular:\n            k_rate *= m\n\n        # Limit the collision rate\n\n        if invert:\n            k0inv, kinfinv, keq = invert_reaction(thermo_products, thermo_reactants, k0, kinf, temperature)\n            # falloff = falloff_function(k0inv, kinfinv, m, temperature, *falloff_coeffs)\n\n            inv_k_rate = k0inv * falloff / (1 + k0inv * m / kinfinv)\n            if unimolecular:\n                inv_k_rate *= m\n\n            inv_k_rate_coll = collision_rate_limit(products, inv_k_rate, kinfinv, m, temperature)\n\n            check_rate = inv_k_rate != inv_k_rate_coll\n\n            k_rate[check_rate] = inv_k_rate_coll[check_rate] * keq[check_rate]\n\n            return [k_rate, inv_k_rate_coll]\n\n        return [k_rate]\n\n    return _react\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.decomposition_plog","title":"<code>decomposition_plog(plog_coeffs, invert, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>Decomposition reaction rate constant.</p> <p>Parameters:</p> Name Type Description Default <code>plog_coeffs</code> <code>list[float]</code> <p>The PLOG rate constant coefficients.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Type Description <code>ReactionFunction</code> <p>A function that takes the concentration of the species and returns the rate</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def decomposition_plog(\n    plog_coeffs: list[float],\n    invert: bool,\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; ReactionFunction:\n    \"\"\"Decomposition reaction rate constant.\n\n    Args:\n        plog_coeffs: The PLOG rate constant coefficients.\n        invert: Whether to invert the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        A function that takes the concentration of the species and returns the rate\n    \"\"\"\n    from scipy.interpolate import RectBivariateSpline\n\n    from freckll.constants import ATM_BAR\n\n    BAR_ATM = 1.0 / ATM_BAR\n\n    p0_plog, a0_plog, n0_plog, er0_plog = np.split(np.array(plog_coeffs), 4)\n    p0_plog = np.log10(p0_plog)\n    p_log = np.log10(pressure * BAR_ATM * 1e-3)\n\n    temperature_test = np.linspace(100, 5000, 5000)\n\n    _, a0 = np.meshgrid(temperature_test, a0_plog, indexing=\"ij\")\n    _, p0 = np.meshgrid(temperature_test, p0_plog, indexing=\"ij\")\n    _, n0 = np.meshgrid(temperature_test, n0_plog, indexing=\"ij\")\n    _temperature, er0 = np.meshgrid(temperature_test, er0_plog, indexing=\"ij\")\n\n    k0_log = arrhenius_constant(a0, n0, er0, _temperature)\n\n    f = RectBivariateSpline(temperature_test, p0_plog, k0_log)\n    k0 = np.array([f(t, p)[0] for t, p in zip(temperature, p_log)])[:, 0]\n\n    def _react(concentration: FreckllArray) -&gt; list[FreckllArray]:\n        m = np.sum(concentration, axis=0)\n\n        krate = k0\n\n        if invert:\n            k0inv, _, keq = invert_reaction(thermo_products, thermo_reactants, k0, np.zeros_like(k0), temperature)\n\n            inv_k_rate = k0inv\n            if len(products) &gt; 1:\n                inv_k_rate_coll = collision_rate_limit(products, inv_k_rate, np.zeros_like(k0), m, temperature)\n\n                check_rate = inv_k_rate != inv_k_rate_coll\n\n                krate[check_rate] = inv_k_rate_coll[check_rate] * keq[check_rate]\n                inv_k_rate = inv_k_rate_coll\n            return [krate, inv_k_rate]\n\n        return [krate]\n\n    return _react\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.decomposition_reaction","title":"<code>decomposition_reaction(k0_coeffs, invert, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>Decomposition reaction rate constant.</p> <p>Parameters:</p> Name Type Description Default <code>k0_coeffs</code> <code>list[float]</code> <p>The low-pressure rate constant coefficients.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Name Type Description <code>k_rate</code> <code>ReactionFunction</code> <p>The rate constant of the reaction.</p> <code>inv_k_rate</code> <code>ReactionFunction</code> <p>The inverted rate constant of the reaction. (if <code>invert</code> is True)</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def decomposition_reaction(\n    k0_coeffs: list[float],\n    invert: bool,\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; ReactionFunction:\n    \"\"\"Decomposition reaction rate constant.\n\n    Args:\n        k0_coeffs: The low-pressure rate constant coefficients.\n        invert: Whether to invert the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        k_rate: The rate constant of the reaction.\n        inv_k_rate: The inverted rate constant of the reaction. (if ``invert`` is True)\n\n    \"\"\"\n    a0, n0, er0, _, _ = k0_coeffs\n\n    k0 = arrhenius_constant(a0, n0, er0, temperature)\n\n    def _react(\n        concentration: FreckllArray,\n        k0: FreckllArray = k0,\n        products: list[SpeciesFormula] = products,\n        temperature: FreckllArray = temperature,\n        thermo_reactants: FreckllArray = thermo_reactants,\n        thermo_products: FreckllArray = thermo_products,\n        invert: bool = invert,\n    ) -&gt; list[FreckllArray]:\n        k_rate = np.copy(k0)\n        m = np.sum(concentration, axis=0)\n        if invert:\n            k0inv, _, keq = invert_reaction(thermo_products, thermo_reactants, k0, np.zeros_like(k0), temperature)\n            inv_k_rate = k0inv\n            if len(products) &gt; 1:\n                inv_k_rate_coll = collision_rate_limit(products, inv_k_rate, np.zeros_like(k0), m, temperature)\n\n                check_rate = k0inv != inv_k_rate_coll\n\n                k_rate[check_rate] = inv_k_rate_coll[check_rate] * keq[check_rate]\n                inv_k_rate = inv_k_rate_coll\n            return [k_rate, inv_k_rate]\n\n        return [k_rate]\n\n    return _react\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.k0_reaction","title":"<code>k0_reaction(k0_coeffs, efficiency, invert, reactants, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>Reaction rate constant.</p> <p>Parameters:</p> Name Type Description Default <code>k0_coeffs</code> <code>list[float]</code> <p>The low-pressure rate constant coefficients.</p> required <code>efficiency</code> <code>FreckllArray</code> <p>The efficiency of the reaction.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants of the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Type Description <code>ReactionFunction</code> <p>A function that takes the concentration of the species and returns the rate</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def k0_reaction(\n    k0_coeffs: list[float],\n    efficiency: FreckllArray,\n    invert: bool,\n    reactants: list[SpeciesFormula],\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; ReactionFunction:\n    \"\"\"Reaction rate constant.\n\n    Args:\n        k0_coeffs: The low-pressure rate constant coefficients.\n        efficiency: The efficiency of the reaction.\n        invert: Whether to invert the reaction.\n        reactants: The reactants of the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        A function that takes the concentration of the species and returns the rate\n\n    \"\"\"\n    a0, n0, er0, _, _ = k0_coeffs\n\n    k0 = arrhenius_constant(a0, n0, er0, temperature)\n\n    def _react(\n        concentration: FreckllArray,\n        k0: FreckllArray = k0,\n        efficiency: FreckllArray = efficiency,\n        reactants: list[SpeciesFormula] = reactants,\n        products: list[SpeciesFormula] = products,\n        temperature: FreckllArray = temperature,\n        thermo_reactants: FreckllArray = thermo_reactants,\n        thermo_products: FreckllArray = thermo_products,\n        invert: bool = invert,\n    ):\n        m = np.sum(concentration * efficiency[:, None], axis=0)\n        k_rate = k0 * m\n        k_rate = collision_rate_limit(reactants, k_rate, np.zeros_like(k0), m, temperature)\n\n        if invert:\n            k0inv, _, keq = invert_reaction(thermo_products, thermo_reactants, k0, np.zeros_like(k0), temperature)\n\n            k0inv_coll = collision_rate_limit(products, k0inv, np.zeros_like(k0), m, temperature)\n\n            inv_k_rate = k0inv_coll * m\n\n            check_rate = k0inv != k0inv_coll\n\n            k_rate[check_rate] = inv_k_rate[check_rate] * keq[check_rate]\n            return [k_rate, inv_k_rate]\n\n        return [k_rate]\n\n    return _react\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.k0kinf_reaction","title":"<code>k0kinf_reaction(k0_coeffs, kinf_coeffs, falloff_coeffs, efficiency, invert, falloff_function, reactants, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>Calculates the effective pressure-dependent rate constant.</p> <p>This the Arrheniues rate with the low-pressure and high pressure limits The low pressure limit is: $$ k_0 = A_0 T^{n_0} \\exp(-E_{r0}/T) $$ The high pressure limit is: $$ k_\\infty = A_i T^{n_i} \\exp(-E_{ri}/T) $$</p> <p>Additionally you can also provide a falloff function to calculate the falloff term.</p> <p>Parameters:</p> Name Type Description Default <code>k0_coeffs</code> <code>list[float]</code> <p>The low-pressure rate constant coefficients.</p> required <code>kinf_coeffs</code> <code>list[float]</code> <p>The high-pressure rate constant coefficients.</p> required <code>falloff_coeffs</code> <code>list[float]</code> <p>The falloff coefficients.</p> required <code>efficiency</code> <code>FreckllArray</code> <p>The efficiency of the reaction.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>falloff_function</code> <code>FalloffFunction</code> <p>The falloff function to use.</p> required <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants of the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Name Type Description <code>k_rate</code> <code>list[FreckllArray]</code> <p>The rate constant of the reaction.</p> <code>inv_k_rate</code> <code>list[FreckllArray]</code> <p>The inverted rate constant of the reaction.</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def k0kinf_reaction(\n    k0_coeffs: list[float],\n    kinf_coeffs: list[float],\n    falloff_coeffs: list[float],\n    efficiency: FreckllArray,\n    invert: bool,\n    falloff_function: FalloffFunction,\n    reactants: list[SpeciesFormula],\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; list[FreckllArray]:\n    r\"\"\"Calculates the effective pressure-dependent rate constant.\n\n    This the Arrheniues rate with the low-pressure and high pressure\n    limits\n    The low pressure limit is:\n    $$\n    k_0 = A_0 T^{n_0} \\exp(-E_{r0}/T)\n    $$\n    The high pressure limit is:\n    $$\n    k_\\infty = A_i T^{n_i} \\exp(-E_{ri}/T)\n    $$\n\n    Additionally you can also provide a falloff function to calculate\n    the falloff term.\n\n    Args:\n        k0_coeffs: The low-pressure rate constant coefficients.\n        kinf_coeffs: The high-pressure rate constant coefficients.\n        falloff_coeffs: The falloff coefficients.\n        efficiency: The efficiency of the reaction.\n        invert: Whether to invert the reaction.\n        falloff_function: The falloff function to use.\n        reactants: The reactants of the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        k_rate: The rate constant of the reaction.\n        inv_k_rate: The inverted rate constant of the reaction.\n\n\n    \"\"\"\n    # k0 terms\n    a0, n0, er0, _, _ = k0_coeffs\n    # kinf terms\n    ai, ni, eri, _, _ = kinf_coeffs\n\n    # Falloff terms\n\n    unimolecular = len(reactants) == 1 or len(products) == 1\n\n    k0 = arrhenius_constant(a0, n0, er0, temperature)\n    kinf = arrhenius_constant(ai, ni, eri, temperature)\n\n    def _react(\n        concentration: FreckllArray,\n        efficiency: FreckllArray = efficiency,\n        k0: FreckllArray = k0,\n        kinf: FreckllArray = kinf,\n        falloff_function: FalloffFunction = falloff_function,\n        reactants: list[SpeciesFormula] = reactants,\n        products: list[SpeciesFormula] = products,\n        temperature: FreckllArray = temperature,\n        falloff_coeffs: list[float] = falloff_coeffs,\n        invert: bool = invert,\n        unimolecular: bool = unimolecular,\n    ) -&gt; list[FreckllArray]:\n        m: FreckllArray = (efficiency[:, None] * concentration).sum(axis=0)\n\n        falloff = falloff_function(\n            k0,\n            kinf,\n            m,\n            temperature,\n            *falloff_coeffs,\n        )\n\n        k_rate = k0 * falloff / (1 + k0 * m / kinf)\n\n        if unimolecular:\n            k_rate *= m\n\n        # Limit the collision rate\n        k_rate = collision_rate_limit(reactants, k_rate, kinf, m, temperature)\n\n        if invert:\n            k0inv, kinfinv, keq = invert_reaction(thermo_products, thermo_reactants, k0, kinf, temperature)\n\n            k0inv_coll = collision_rate_limit(products, k0inv, kinfinv, m, temperature)\n            falloff = falloff_function(k0inv_coll, kinfinv, m, temperature, *falloff_coeffs)\n\n            inv_k_rate = k0inv_coll * falloff / (1 + k0inv_coll * m / kinfinv)\n\n            if unimolecular:\n                inv_k_rate *= m\n\n            check_rate = k0inv != k0inv_coll\n\n            k_rate[check_rate] = inv_k_rate[check_rate] * keq[check_rate]\n\n            return [k_rate, inv_k_rate]\n\n        return [k_rate]\n\n    return _react\n</code></pre>"},{"location":"modules/reactions/reactions/#freckll.reactions.reactions.manybody_plog_reaction","title":"<code>manybody_plog_reaction(plog_coeffs, invert, reactants, products, temperature, pressure, thermo_reactants, thermo_products)</code>","text":"<p>Many body reaction rate constant.</p> <p>Parameters:</p> Name Type Description Default <code>plog_coeffs</code> <code>list[float]</code> <p>The PLOG rate constant coefficients.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the reaction.</p> required <code>reactants</code> <code>list[SpeciesFormula]</code> <p>The reactants of the reaction.</p> required <code>products</code> <code>list[SpeciesFormula]</code> <p>The products of the reaction.</p> required <code>temperature</code> <code>FreckllArray</code> <p>The temperature of the species.</p> required <code>pressure</code> <code>FreckllArray</code> <p>The pressure of the species.</p> required <code>thermo_reactants</code> <code>FreckllArray</code> <p>The thermodynamic properties of the reactants.</p> required <code>thermo_products</code> <code>FreckllArray</code> <p>The thermodynamic properties of the products.</p> required <p>Returns:</p> Type Description <code>ReactionFunction</code> <p>A function that takes the concentration of the species and returns the rate</p> Source code in <code>src/freckll/reactions/reactions.py</code> <pre><code>def manybody_plog_reaction(\n    plog_coeffs: list[float],\n    invert: bool,\n    reactants: list[SpeciesFormula],\n    products: list[SpeciesFormula],\n    temperature: FreckllArray,\n    pressure: FreckllArray,\n    thermo_reactants: FreckllArray,\n    thermo_products: FreckllArray,\n) -&gt; ReactionFunction:\n    \"\"\"Many body reaction rate constant.\n\n    Args:\n        plog_coeffs: The PLOG rate constant coefficients.\n        invert: Whether to invert the reaction.\n        reactants: The reactants of the reaction.\n        products: The products of the reaction.\n        temperature: The temperature of the species.\n        pressure: The pressure of the species.\n        thermo_reactants: The thermodynamic properties of the reactants.\n        thermo_products: The thermodynamic properties of the products.\n\n    Returns:\n        A function that takes the concentration of the species and returns the rate\n\n    \"\"\"\n    from scipy.interpolate import RectBivariateSpline\n\n    from freckll.constants import ATM_BAR\n\n    BAR_ATM = 1.0 / ATM_BAR\n\n    p0_plog, a0_plog, n0_plog, er0_plog = np.split(np.array(plog_coeffs), 4)\n    p0_plog = np.log10(p0_plog)\n    p_log = np.log10(pressure * BAR_ATM * 1e-3)\n\n    temperature_test = np.linspace(100, 5000, 5000)\n\n    _, a0 = np.meshgrid(temperature_test, a0_plog, indexing=\"ij\")\n    _, p0 = np.meshgrid(temperature_test, p0_plog, indexing=\"ij\")\n    _, n0 = np.meshgrid(temperature_test, n0_plog, indexing=\"ij\")\n    _temperature, er0 = np.meshgrid(temperature_test, er0_plog, indexing=\"ij\")\n\n    k0_log = arrhenius_constant(a0, n0, er0, _temperature)\n\n    f = RectBivariateSpline(temperature_test, p0_plog, k0_log)\n    k0 = np.array([f(t, p)[0] for t, p in zip(temperature, p_log)])[:, 0]\n\n    def _react(concentration: FreckllArray) -&gt; list[FreckllArray]:\n        m = np.sum(concentration, axis=0)\n\n        krate = k0\n        if len(reactants) &lt; 3:\n            krate = collision_rate_limit(reactants, k0, np.zeros_like(k0), m, temperature)\n\n        if invert:\n            k0inv, _, keq = invert_reaction(thermo_products, thermo_reactants, k0, np.zeros_like(k0), temperature)\n\n            inv_k_rate = k0inv\n            if len(products) &gt; 1:\n                inv_k_rate_coll = collision_rate_limit(products, inv_k_rate, np.zeros_like(k0), m, temperature)\n\n                check_rate = inv_k_rate != inv_k_rate_coll\n\n                krate[check_rate] = inv_k_rate_coll[check_rate] * keq[check_rate]\n                inv_k_rate = inv_k_rate_coll\n            return [krate, inv_k_rate]\n\n        return [krate]\n\n    return _react\n</code></pre>"}]}